// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `all.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  THE MAIN THINGS
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.QueryResponse)
pub struct QueryResponse {
    // message fields
    // @@protoc_insertion_point(field:all.QueryResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:all.QueryResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:all.QueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryResponse {
    fn default() -> &'a QueryResponse {
        <QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &QueryResponse| { &m.success },
            |m: &mut QueryResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &QueryResponse| { &m.message },
            |m: &mut QueryResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryResponse>(
            "QueryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryResponse {
    const NAME: &'static str = "QueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryResponse {
        static instance: QueryResponse = QueryResponse {
            success: false,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.AllDomainSchema)
pub struct AllDomainSchema {
    // message fields
    // @@protoc_insertion_point(field:all.AllDomainSchema.everything)
    pub everything: ::std::vec::Vec<FullDomainSchema>,
    // special fields
    // @@protoc_insertion_point(special_field:all.AllDomainSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllDomainSchema {
    fn default() -> &'a AllDomainSchema {
        <AllDomainSchema as ::protobuf::Message>::default_instance()
    }
}

impl AllDomainSchema {
    pub fn new() -> AllDomainSchema {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "everything",
            |m: &AllDomainSchema| { &m.everything },
            |m: &mut AllDomainSchema| { &mut m.everything },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllDomainSchema>(
            "AllDomainSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllDomainSchema {
    const NAME: &'static str = "AllDomainSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.everything.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.everything {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.everything {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllDomainSchema {
        AllDomainSchema::new()
    }

    fn clear(&mut self) {
        self.everything.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllDomainSchema {
        static instance: AllDomainSchema = AllDomainSchema {
            everything: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllDomainSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllDomainSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllDomainSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllDomainSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  for when a domain is updated, only the difference is sent
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.PartialDomainSchema)
pub struct PartialDomainSchema {
    // message fields
    // @@protoc_insertion_point(field:all.PartialDomainSchema.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.origin_settings)
    pub origin_settings: ::std::collections::HashMap<::std::string::String, OriginSetting>,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.api_engine_settings)
    pub api_engine_settings: ::protobuf::MessageField<ApiEngineSettings>,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.bot_settings)
    pub bot_settings: ::protobuf::MessageField<BotSettings>,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.cache_settings)
    pub cache_settings: ::protobuf::MessageField<CachingSettings>,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.buckets)
    pub buckets: ::protobuf::MessageField<BucketSettings>,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.page_rules)
    pub page_rules: ::protobuf::MessageField<PageRules>,
    // @@protoc_insertion_point(field:all.PartialDomainSchema.internal_settings)
    pub internal_settings: ::protobuf::MessageField<InternalSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:all.PartialDomainSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartialDomainSchema {
    fn default() -> &'a PartialDomainSchema {
        <PartialDomainSchema as ::protobuf::Message>::default_instance()
    }
}

impl PartialDomainSchema {
    pub fn new() -> PartialDomainSchema {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &PartialDomainSchema| { &m.domain },
            |m: &mut PartialDomainSchema| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "origin_settings",
            |m: &PartialDomainSchema| { &m.origin_settings },
            |m: &mut PartialDomainSchema| { &mut m.origin_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ApiEngineSettings>(
            "api_engine_settings",
            |m: &PartialDomainSchema| { &m.api_engine_settings },
            |m: &mut PartialDomainSchema| { &mut m.api_engine_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BotSettings>(
            "bot_settings",
            |m: &PartialDomainSchema| { &m.bot_settings },
            |m: &mut PartialDomainSchema| { &mut m.bot_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CachingSettings>(
            "cache_settings",
            |m: &PartialDomainSchema| { &m.cache_settings },
            |m: &mut PartialDomainSchema| { &mut m.cache_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BucketSettings>(
            "buckets",
            |m: &PartialDomainSchema| { &m.buckets },
            |m: &mut PartialDomainSchema| { &mut m.buckets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PageRules>(
            "page_rules",
            |m: &PartialDomainSchema| { &m.page_rules },
            |m: &mut PartialDomainSchema| { &mut m.page_rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InternalSettings>(
            "internal_settings",
            |m: &PartialDomainSchema| { &m.internal_settings },
            |m: &mut PartialDomainSchema| { &mut m.internal_settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartialDomainSchema>(
            "PartialDomainSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartialDomainSchema {
    const NAME: &'static str = "PartialDomainSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.origin_settings.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.api_engine_settings)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bot_settings)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cache_settings)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buckets)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.page_rules)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.internal_settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        for (k, v) in &self.origin_settings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.api_engine_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bot_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cache_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buckets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.page_rules.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.internal_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        for (k, v) in &self.origin_settings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.api_engine_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.bot_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.cache_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.buckets.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.page_rules.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.internal_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartialDomainSchema {
        PartialDomainSchema::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.origin_settings.clear();
        self.api_engine_settings.clear();
        self.bot_settings.clear();
        self.cache_settings.clear();
        self.buckets.clear();
        self.page_rules.clear();
        self.internal_settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartialDomainSchema {
        static instance: ::protobuf::rt::Lazy<PartialDomainSchema> = ::protobuf::rt::Lazy::new();
        instance.get(PartialDomainSchema::new)
    }
}

impl ::protobuf::MessageFull for PartialDomainSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartialDomainSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartialDomainSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartialDomainSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.FullDomainSchema)
pub struct FullDomainSchema {
    // message fields
    // @@protoc_insertion_point(field:all.FullDomainSchema.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:all.FullDomainSchema.origin_settings)
    pub origin_settings: ::std::collections::HashMap<::std::string::String, OriginSetting>,
    // @@protoc_insertion_point(field:all.FullDomainSchema.api_engine_settings)
    pub api_engine_settings: ::protobuf::MessageField<ApiEngineSettings>,
    // @@protoc_insertion_point(field:all.FullDomainSchema.cache_settings)
    pub cache_settings: ::protobuf::MessageField<CachingSettings>,
    // @@protoc_insertion_point(field:all.FullDomainSchema.buckets)
    pub buckets: ::protobuf::MessageField<BucketSettings>,
    // @@protoc_insertion_point(field:all.FullDomainSchema.page_rules)
    pub page_rules: ::protobuf::MessageField<PageRules>,
    // @@protoc_insertion_point(field:all.FullDomainSchema.internal_settings)
    pub internal_settings: ::protobuf::MessageField<InternalSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:all.FullDomainSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FullDomainSchema {
    fn default() -> &'a FullDomainSchema {
        <FullDomainSchema as ::protobuf::Message>::default_instance()
    }
}

impl FullDomainSchema {
    pub fn new() -> FullDomainSchema {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &FullDomainSchema| { &m.domain },
            |m: &mut FullDomainSchema| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "origin_settings",
            |m: &FullDomainSchema| { &m.origin_settings },
            |m: &mut FullDomainSchema| { &mut m.origin_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ApiEngineSettings>(
            "api_engine_settings",
            |m: &FullDomainSchema| { &m.api_engine_settings },
            |m: &mut FullDomainSchema| { &mut m.api_engine_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CachingSettings>(
            "cache_settings",
            |m: &FullDomainSchema| { &m.cache_settings },
            |m: &mut FullDomainSchema| { &mut m.cache_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BucketSettings>(
            "buckets",
            |m: &FullDomainSchema| { &m.buckets },
            |m: &mut FullDomainSchema| { &mut m.buckets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PageRules>(
            "page_rules",
            |m: &FullDomainSchema| { &m.page_rules },
            |m: &mut FullDomainSchema| { &mut m.page_rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InternalSettings>(
            "internal_settings",
            |m: &FullDomainSchema| { &m.internal_settings },
            |m: &mut FullDomainSchema| { &mut m.internal_settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FullDomainSchema>(
            "FullDomainSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FullDomainSchema {
    const NAME: &'static str = "FullDomainSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.origin_settings.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.api_engine_settings)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cache_settings)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buckets)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.page_rules)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.internal_settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        for (k, v) in &self.origin_settings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.api_engine_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cache_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buckets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.page_rules.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.internal_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        for (k, v) in &self.origin_settings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.api_engine_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.cache_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.buckets.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.page_rules.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.internal_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FullDomainSchema {
        FullDomainSchema::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.origin_settings.clear();
        self.api_engine_settings.clear();
        self.cache_settings.clear();
        self.buckets.clear();
        self.page_rules.clear();
        self.internal_settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FullDomainSchema {
        static instance: ::protobuf::rt::Lazy<FullDomainSchema> = ::protobuf::rt::Lazy::new();
        instance.get(FullDomainSchema::new)
    }
}

impl ::protobuf::MessageFull for FullDomainSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FullDomainSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FullDomainSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FullDomainSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.DeleteDomainSchema)
pub struct DeleteDomainSchema {
    // message fields
    // @@protoc_insertion_point(field:all.DeleteDomainSchema.domain)
    pub domain: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:all.DeleteDomainSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDomainSchema {
    fn default() -> &'a DeleteDomainSchema {
        <DeleteDomainSchema as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDomainSchema {
    pub fn new() -> DeleteDomainSchema {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &DeleteDomainSchema| { &m.domain },
            |m: &mut DeleteDomainSchema| { &mut m.domain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDomainSchema>(
            "DeleteDomainSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDomainSchema {
    const NAME: &'static str = "DeleteDomainSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDomainSchema {
        DeleteDomainSchema::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDomainSchema {
        static instance: DeleteDomainSchema = DeleteDomainSchema {
            domain: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDomainSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDomainSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDomainSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDomainSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ORIGINS
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.OriginSetting)
pub struct OriginSetting {
    // message fields
    // @@protoc_insertion_point(field:all.OriginSetting.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:all.OriginSetting.ssl)
    pub ssl: bool,
    // @@protoc_insertion_point(field:all.OriginSetting.http2)
    pub http2: bool,
    // @@protoc_insertion_point(field:all.OriginSetting.timeout)
    pub timeout: i32,
    // @@protoc_insertion_point(field:all.OriginSetting.ip_data)
    pub ip_data: bool,
    ///  origins themselves
    // @@protoc_insertion_point(field:all.OriginSetting.origins)
    pub origins: ::std::vec::Vec<Origin>,
    // special fields
    // @@protoc_insertion_point(special_field:all.OriginSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OriginSetting {
    fn default() -> &'a OriginSetting {
        <OriginSetting as ::protobuf::Message>::default_instance()
    }
}

impl OriginSetting {
    pub fn new() -> OriginSetting {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &OriginSetting| { &m.host },
            |m: &mut OriginSetting| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ssl",
            |m: &OriginSetting| { &m.ssl },
            |m: &mut OriginSetting| { &mut m.ssl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "http2",
            |m: &OriginSetting| { &m.http2 },
            |m: &mut OriginSetting| { &mut m.http2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeout",
            |m: &OriginSetting| { &m.timeout },
            |m: &mut OriginSetting| { &mut m.timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ip_data",
            |m: &OriginSetting| { &m.ip_data },
            |m: &mut OriginSetting| { &mut m.ip_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "origins",
            |m: &OriginSetting| { &m.origins },
            |m: &mut OriginSetting| { &mut m.origins },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OriginSetting>(
            "OriginSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OriginSetting {
    const NAME: &'static str = "OriginSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_string()?;
                },
                16 => {
                    self.ssl = is.read_bool()?;
                },
                24 => {
                    self.http2 = is.read_bool()?;
                },
                32 => {
                    self.timeout = is.read_sint32()?;
                },
                48 => {
                    self.ip_data = is.read_bool()?;
                },
                58 => {
                    self.origins.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.ssl != false {
            my_size += 1 + 1;
        }
        if self.http2 != false {
            my_size += 1 + 1;
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::sint32_size(4, self.timeout);
        }
        if self.ip_data != false {
            my_size += 1 + 1;
        }
        for value in &self.origins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.ssl != false {
            os.write_bool(2, self.ssl)?;
        }
        if self.http2 != false {
            os.write_bool(3, self.http2)?;
        }
        if self.timeout != 0 {
            os.write_sint32(4, self.timeout)?;
        }
        if self.ip_data != false {
            os.write_bool(6, self.ip_data)?;
        }
        for v in &self.origins {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OriginSetting {
        OriginSetting::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.ssl = false;
        self.http2 = false;
        self.timeout = 0;
        self.ip_data = false;
        self.origins.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OriginSetting {
        static instance: OriginSetting = OriginSetting {
            host: ::std::string::String::new(),
            ssl: false,
            http2: false,
            timeout: 0,
            ip_data: false,
            origins: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OriginSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OriginSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OriginSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OriginSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.Origin)
pub struct Origin {
    // message fields
    // @@protoc_insertion_point(field:all.Origin.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:all.Origin.weight)
    pub weight: i32,
    // special fields
    // @@protoc_insertion_point(special_field:all.Origin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Origin {
    fn default() -> &'a Origin {
        <Origin as ::protobuf::Message>::default_instance()
    }
}

impl Origin {
    pub fn new() -> Origin {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Origin| { &m.url },
            |m: &mut Origin| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "weight",
            |m: &Origin| { &m.weight },
            |m: &mut Origin| { &mut m.weight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Origin>(
            "Origin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Origin {
    const NAME: &'static str = "Origin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                16 => {
                    self.weight = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.weight);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if self.weight != 0 {
            os.write_sint32(2, self.weight)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Origin {
        Origin::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.weight = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Origin {
        static instance: Origin = Origin {
            url: ::std::string::String::new(),
            weight: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Origin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Origin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Origin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Origin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  API ENGINE
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.ApiEngineSettings)
pub struct ApiEngineSettings {
    // message fields
    // @@protoc_insertion_point(field:all.ApiEngineSettings.enabled)
    pub enabled: bool,
    // @@protoc_insertion_point(field:all.ApiEngineSettings.settings)
    pub settings: ::std::collections::HashMap<::std::string::String, ApiEngineSetting>,
    // special fields
    // @@protoc_insertion_point(special_field:all.ApiEngineSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiEngineSettings {
    fn default() -> &'a ApiEngineSettings {
        <ApiEngineSettings as ::protobuf::Message>::default_instance()
    }
}

impl ApiEngineSettings {
    pub fn new() -> ApiEngineSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &ApiEngineSettings| { &m.enabled },
            |m: &mut ApiEngineSettings| { &mut m.enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "settings",
            |m: &ApiEngineSettings| { &m.settings },
            |m: &mut ApiEngineSettings| { &mut m.settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiEngineSettings>(
            "ApiEngineSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiEngineSettings {
    const NAME: &'static str = "ApiEngineSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = is.read_bool()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.settings.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.settings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        for (k, v) in &self.settings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiEngineSettings {
        ApiEngineSettings::new()
    }

    fn clear(&mut self) {
        self.enabled = false;
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiEngineSettings {
        static instance: ::protobuf::rt::Lazy<ApiEngineSettings> = ::protobuf::rt::Lazy::new();
        instance.get(ApiEngineSettings::new)
    }
}

impl ::protobuf::MessageFull for ApiEngineSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiEngineSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiEngineSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiEngineSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.ApiEngineSetting)
pub struct ApiEngineSetting {
    // message fields
    // @@protoc_insertion_point(field:all.ApiEngineSetting.kv_whitelist_factors)
    pub kv_whitelist_factors: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:all.ApiEngineSetting.ips)
    pub ips: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:all.ApiEngineSetting.rules)
    pub rules: ::std::vec::Vec<ApiEngineRule>,
    // special fields
    // @@protoc_insertion_point(special_field:all.ApiEngineSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiEngineSetting {
    fn default() -> &'a ApiEngineSetting {
        <ApiEngineSetting as ::protobuf::Message>::default_instance()
    }
}

impl ApiEngineSetting {
    pub fn new() -> ApiEngineSetting {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "kv_whitelist_factors",
            |m: &ApiEngineSetting| { &m.kv_whitelist_factors },
            |m: &mut ApiEngineSetting| { &mut m.kv_whitelist_factors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ips",
            |m: &ApiEngineSetting| { &m.ips },
            |m: &mut ApiEngineSetting| { &mut m.ips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &ApiEngineSetting| { &m.rules },
            |m: &mut ApiEngineSetting| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiEngineSetting>(
            "ApiEngineSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiEngineSetting {
    const NAME: &'static str = "ApiEngineSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.kv_whitelist_factors.insert(key, value);
                },
                18 => {
                    self.ips.push(is.read_string()?);
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.kv_whitelist_factors {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.ips {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.kv_whitelist_factors {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.ips {
            os.write_string(2, &v)?;
        };
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiEngineSetting {
        ApiEngineSetting::new()
    }

    fn clear(&mut self) {
        self.kv_whitelist_factors.clear();
        self.ips.clear();
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiEngineSetting {
        static instance: ::protobuf::rt::Lazy<ApiEngineSetting> = ::protobuf::rt::Lazy::new();
        instance.get(ApiEngineSetting::new)
    }
}

impl ::protobuf::MessageFull for ApiEngineSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiEngineSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiEngineSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiEngineSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.ApiEngineRule)
pub struct ApiEngineRule {
    // message fields
    // @@protoc_insertion_point(field:all.ApiEngineRule.position)
    pub position: i32,
    // @@protoc_insertion_point(field:all.ApiEngineRule.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:all.ApiEngineRule.match_type)
    pub match_type: ::protobuf::EnumOrUnknown<MatchType>,
    // @@protoc_insertion_point(field:all.ApiEngineRule.allow_query_string)
    pub allow_query_string: bool,
    // @@protoc_insertion_point(field:all.ApiEngineRule.ws_methods)
    pub ws_methods: ::std::vec::Vec<::protobuf::EnumOrUnknown<WsMethods>>,
    // @@protoc_insertion_point(field:all.ApiEngineRule.web_methods)
    pub web_methods: ::std::vec::Vec<::protobuf::EnumOrUnknown<WebMethods>>,
    // @@protoc_insertion_point(field:all.ApiEngineRule.ratelimiting_bucket)
    pub ratelimiting_bucket: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:all.ApiEngineRule.cache_level)
    pub cache_level: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:all.ApiEngineRule.cache_level_ttl)
    pub cache_level_ttl: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:all.ApiEngineRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiEngineRule {
    fn default() -> &'a ApiEngineRule {
        <ApiEngineRule as ::protobuf::Message>::default_instance()
    }
}

impl ApiEngineRule {
    pub fn new() -> ApiEngineRule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &ApiEngineRule| { &m.position },
            |m: &mut ApiEngineRule| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ApiEngineRule| { &m.path },
            |m: &mut ApiEngineRule| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "match_type",
            |m: &ApiEngineRule| { &m.match_type },
            |m: &mut ApiEngineRule| { &mut m.match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_query_string",
            |m: &ApiEngineRule| { &m.allow_query_string },
            |m: &mut ApiEngineRule| { &mut m.allow_query_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ws_methods",
            |m: &ApiEngineRule| { &m.ws_methods },
            |m: &mut ApiEngineRule| { &mut m.ws_methods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "web_methods",
            |m: &ApiEngineRule| { &m.web_methods },
            |m: &mut ApiEngineRule| { &mut m.web_methods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ratelimiting_bucket",
            |m: &ApiEngineRule| { &m.ratelimiting_bucket },
            |m: &mut ApiEngineRule| { &mut m.ratelimiting_bucket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_level",
            |m: &ApiEngineRule| { &m.cache_level },
            |m: &mut ApiEngineRule| { &mut m.cache_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_level_ttl",
            |m: &ApiEngineRule| { &m.cache_level_ttl },
            |m: &mut ApiEngineRule| { &mut m.cache_level_ttl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiEngineRule>(
            "ApiEngineRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiEngineRule {
    const NAME: &'static str = "ApiEngineRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.position = is.read_sint32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.match_type = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.allow_query_string = is.read_bool()?;
                },
                40 => {
                    self.ws_methods.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.ws_methods)?
                },
                48 => {
                    self.web_methods.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.web_methods)?
                },
                58 => {
                    self.ratelimiting_bucket = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.cache_level = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.cache_level_ttl = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.position != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.position);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(MatchType::Exact) {
            my_size += ::protobuf::rt::int32_size(3, self.match_type.value());
        }
        if self.allow_query_string != false {
            my_size += 1 + 1;
        }
        for value in &self.ws_methods {
            my_size += ::protobuf::rt::int32_size(5, value.value());
        };
        for value in &self.web_methods {
            my_size += ::protobuf::rt::int32_size(6, value.value());
        };
        if let Some(v) = self.ratelimiting_bucket.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.cache_level.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.cache_level_ttl {
            my_size += ::protobuf::rt::sint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.position != 0 {
            os.write_sint32(1, self.position)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(MatchType::Exact) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.match_type))?;
        }
        if self.allow_query_string != false {
            os.write_bool(4, self.allow_query_string)?;
        }
        for v in &self.ws_methods {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.web_methods {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.ratelimiting_bucket.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.cache_level.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.cache_level_ttl {
            os.write_sint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiEngineRule {
        ApiEngineRule::new()
    }

    fn clear(&mut self) {
        self.position = 0;
        self.path.clear();
        self.match_type = ::protobuf::EnumOrUnknown::new(MatchType::Exact);
        self.allow_query_string = false;
        self.ws_methods.clear();
        self.web_methods.clear();
        self.ratelimiting_bucket = ::std::option::Option::None;
        self.cache_level = ::std::option::Option::None;
        self.cache_level_ttl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiEngineRule {
        static instance: ApiEngineRule = ApiEngineRule {
            position: 0,
            path: ::std::string::String::new(),
            match_type: ::protobuf::EnumOrUnknown::from_i32(0),
            allow_query_string: false,
            ws_methods: ::std::vec::Vec::new(),
            web_methods: ::std::vec::Vec::new(),
            ratelimiting_bucket: ::std::option::Option::None,
            cache_level: ::std::option::Option::None,
            cache_level_ttl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApiEngineRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiEngineRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiEngineRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiEngineRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CACHING SETTINGS
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.CachingSettings)
pub struct CachingSettings {
    // message fields
    // @@protoc_insertion_point(field:all.CachingSettings.enabled)
    pub enabled: bool,
    // @@protoc_insertion_point(field:all.CachingSettings.cache_level)
    pub cache_level: ::protobuf::EnumOrUnknown<CacheLevel>,
    // @@protoc_insertion_point(field:all.CachingSettings.default_ttl)
    pub default_ttl: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:all.CachingSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CachingSettings {
    fn default() -> &'a CachingSettings {
        <CachingSettings as ::protobuf::Message>::default_instance()
    }
}

impl CachingSettings {
    pub fn new() -> CachingSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &CachingSettings| { &m.enabled },
            |m: &mut CachingSettings| { &mut m.enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cache_level",
            |m: &CachingSettings| { &m.cache_level },
            |m: &mut CachingSettings| { &mut m.cache_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_ttl",
            |m: &CachingSettings| { &m.default_ttl },
            |m: &mut CachingSettings| { &mut m.default_ttl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CachingSettings>(
            "CachingSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CachingSettings {
    const NAME: &'static str = "CachingSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = is.read_bool()?;
                },
                16 => {
                    self.cache_level = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.default_ttl = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 1 + 1;
        }
        if self.cache_level != ::protobuf::EnumOrUnknown::new(CacheLevel::None) {
            my_size += ::protobuf::rt::int32_size(2, self.cache_level.value());
        }
        if let Some(v) = self.default_ttl {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.cache_level != ::protobuf::EnumOrUnknown::new(CacheLevel::None) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.cache_level))?;
        }
        if let Some(v) = self.default_ttl {
            os.write_sint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CachingSettings {
        CachingSettings::new()
    }

    fn clear(&mut self) {
        self.enabled = false;
        self.cache_level = ::protobuf::EnumOrUnknown::new(CacheLevel::None);
        self.default_ttl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CachingSettings {
        static instance: CachingSettings = CachingSettings {
            enabled: false,
            cache_level: ::protobuf::EnumOrUnknown::from_i32(0),
            default_ttl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CachingSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CachingSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CachingSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachingSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BOT SETTINGS
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.BotSettings)
pub struct BotSettings {
    // message fields
    // @@protoc_insertion_point(field:all.BotSettings.enabled)
    pub enabled: bool,
    // @@protoc_insertion_point(field:all.BotSettings.bots)
    pub bots: ::std::vec::Vec<::protobuf::EnumOrUnknown<Bot>>,
    // special fields
    // @@protoc_insertion_point(special_field:all.BotSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BotSettings {
    fn default() -> &'a BotSettings {
        <BotSettings as ::protobuf::Message>::default_instance()
    }
}

impl BotSettings {
    pub fn new() -> BotSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &BotSettings| { &m.enabled },
            |m: &mut BotSettings| { &mut m.enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bots",
            |m: &BotSettings| { &m.bots },
            |m: &mut BotSettings| { &mut m.bots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BotSettings>(
            "BotSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BotSettings {
    const NAME: &'static str = "BotSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = is.read_bool()?;
                },
                16 => {
                    self.bots.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.bots)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 1 + 1;
        }
        for value in &self.bots {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        for v in &self.bots {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BotSettings {
        BotSettings::new()
    }

    fn clear(&mut self) {
        self.enabled = false;
        self.bots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BotSettings {
        static instance: BotSettings = BotSettings {
            enabled: false,
            bots: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BotSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BotSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BotSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BotSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  RATELIMITING BUCKET SETTINGS
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.BucketSettings)
pub struct BucketSettings {
    // message fields
    // @@protoc_insertion_point(field:all.BucketSettings.buckets)
    pub buckets: ::std::vec::Vec<Bucket>,
    // special fields
    // @@protoc_insertion_point(special_field:all.BucketSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BucketSettings {
    fn default() -> &'a BucketSettings {
        <BucketSettings as ::protobuf::Message>::default_instance()
    }
}

impl BucketSettings {
    pub fn new() -> BucketSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buckets",
            |m: &BucketSettings| { &m.buckets },
            |m: &mut BucketSettings| { &mut m.buckets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BucketSettings>(
            "BucketSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BucketSettings {
    const NAME: &'static str = "BucketSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buckets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.buckets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.buckets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BucketSettings {
        BucketSettings::new()
    }

    fn clear(&mut self) {
        self.buckets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BucketSettings {
        static instance: BucketSettings = BucketSettings {
            buckets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BucketSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BucketSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BucketSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.Bucket)
pub struct Bucket {
    // message fields
    // @@protoc_insertion_point(field:all.Bucket.threshold)
    pub threshold: i32,
    // @@protoc_insertion_point(field:all.Bucket.timeout)
    pub timeout: i32,
    // special fields
    // @@protoc_insertion_point(special_field:all.Bucket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Bucket {
    fn default() -> &'a Bucket {
        <Bucket as ::protobuf::Message>::default_instance()
    }
}

impl Bucket {
    pub fn new() -> Bucket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threshold",
            |m: &Bucket| { &m.threshold },
            |m: &mut Bucket| { &mut m.threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeout",
            |m: &Bucket| { &m.timeout },
            |m: &mut Bucket| { &mut m.timeout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bucket>(
            "Bucket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Bucket {
    const NAME: &'static str = "Bucket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.threshold = is.read_sint32()?;
                },
                16 => {
                    self.timeout = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.threshold != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.threshold);
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.timeout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.threshold != 0 {
            os.write_sint32(1, self.threshold)?;
        }
        if self.timeout != 0 {
            os.write_sint32(2, self.timeout)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Bucket {
        Bucket::new()
    }

    fn clear(&mut self) {
        self.threshold = 0;
        self.timeout = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Bucket {
        static instance: Bucket = Bucket {
            threshold: 0,
            timeout: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Bucket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Bucket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Bucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PAGE RULES
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.PageRules)
pub struct PageRules {
    // message fields
    // @@protoc_insertion_point(field:all.PageRules.enabled)
    pub enabled: bool,
    // @@protoc_insertion_point(field:all.PageRules.rules)
    pub rules: ::std::vec::Vec<PageRule>,
    // special fields
    // @@protoc_insertion_point(special_field:all.PageRules.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PageRules {
    fn default() -> &'a PageRules {
        <PageRules as ::protobuf::Message>::default_instance()
    }
}

impl PageRules {
    pub fn new() -> PageRules {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &PageRules| { &m.enabled },
            |m: &mut PageRules| { &mut m.enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &PageRules| { &m.rules },
            |m: &mut PageRules| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PageRules>(
            "PageRules",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PageRules {
    const NAME: &'static str = "PageRules";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = is.read_bool()?;
                },
                18 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 1 + 1;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PageRules {
        PageRules::new()
    }

    fn clear(&mut self) {
        self.enabled = false;
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PageRules {
        static instance: PageRules = PageRules {
            enabled: false,
            rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PageRules {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PageRules").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PageRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PageRules {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.PageRule)
pub struct PageRule {
    // message fields
    // @@protoc_insertion_point(field:all.PageRule.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:all.PageRule.order)
    pub order: i32,
    // @@protoc_insertion_point(field:all.PageRule.matches)
    pub matches: ::std::vec::Vec<Match>,
    // @@protoc_insertion_point(field:all.PageRule.trigger_requirement)
    pub trigger_requirement: ::std::string::String,
    // @@protoc_insertion_point(field:all.PageRule.action)
    pub action: ::protobuf::EnumOrUnknown<Action>,
    ///  if action is monopoly ...
    // @@protoc_insertion_point(field:all.PageRule.monopoly_action)
    pub monopoly_action: ::protobuf::EnumOrUnknown<MonopolyAction>,
    ///  if action is a trustbust ...
    // @@protoc_insertion_point(field:all.PageRule.trustbust_option)
    pub trustbust_option: ::std::vec::Vec<::protobuf::EnumOrUnknown<TrustBustOption>>,
    ///  special action information
    // @@protoc_insertion_point(field:all.PageRule.bucket_name)
    pub bucket_name: ::std::option::Option<::std::string::String>,
    ///  caching
    // @@protoc_insertion_point(field:all.PageRule.cache_level)
    pub cache_level: ::std::option::Option<::protobuf::EnumOrUnknown<CacheLevel>>,
    // @@protoc_insertion_point(field:all.PageRule.cache_ttl)
    pub cache_ttl: ::std::option::Option<i32>,
    ///  redirect to
    // @@protoc_insertion_point(field:all.PageRule.redirect)
    pub redirect: ::std::option::Option<::std::string::String>,
    ///  use backend, fetch from host
    // @@protoc_insertion_point(field:all.PageRule.backend_host)
    pub backend_host: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:all.PageRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PageRule {
    fn default() -> &'a PageRule {
        <PageRule as ::protobuf::Message>::default_instance()
    }
}

impl PageRule {
    pub fn new() -> PageRule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PageRule| { &m.id },
            |m: &mut PageRule| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order",
            |m: &PageRule| { &m.order },
            |m: &mut PageRule| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &PageRule| { &m.matches },
            |m: &mut PageRule| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trigger_requirement",
            |m: &PageRule| { &m.trigger_requirement },
            |m: &mut PageRule| { &mut m.trigger_requirement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PageRule| { &m.action },
            |m: &mut PageRule| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "monopoly_action",
            |m: &PageRule| { &m.monopoly_action },
            |m: &mut PageRule| { &mut m.monopoly_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trustbust_option",
            |m: &PageRule| { &m.trustbust_option },
            |m: &mut PageRule| { &mut m.trustbust_option },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bucket_name",
            |m: &PageRule| { &m.bucket_name },
            |m: &mut PageRule| { &mut m.bucket_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_level",
            |m: &PageRule| { &m.cache_level },
            |m: &mut PageRule| { &mut m.cache_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_ttl",
            |m: &PageRule| { &m.cache_ttl },
            |m: &mut PageRule| { &mut m.cache_ttl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redirect",
            |m: &PageRule| { &m.redirect },
            |m: &mut PageRule| { &mut m.redirect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backend_host",
            |m: &PageRule| { &m.backend_host },
            |m: &mut PageRule| { &mut m.backend_host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PageRule>(
            "PageRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PageRule {
    const NAME: &'static str = "PageRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.order = is.read_sint32()?;
                },
                26 => {
                    self.matches.push(is.read_message()?);
                },
                34 => {
                    self.trigger_requirement = is.read_string()?;
                },
                40 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.monopoly_action = is.read_enum_or_unknown()?;
                },
                56 => {
                    self.trustbust_option.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.trustbust_option)?
                },
                66 => {
                    self.bucket_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.cache_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.cache_ttl = ::std::option::Option::Some(is.read_sint32()?);
                },
                90 => {
                    self.redirect = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.backend_host = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.order != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.order);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.trigger_requirement.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trigger_requirement);
        }
        if self.action != ::protobuf::EnumOrUnknown::new(Action::Monopoly) {
            my_size += ::protobuf::rt::int32_size(5, self.action.value());
        }
        if self.monopoly_action != ::protobuf::EnumOrUnknown::new(MonopolyAction::Block) {
            my_size += ::protobuf::rt::int32_size(6, self.monopoly_action.value());
        }
        for value in &self.trustbust_option {
            my_size += ::protobuf::rt::int32_size(7, value.value());
        };
        if let Some(v) = self.bucket_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.cache_level {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.cache_ttl {
            my_size += ::protobuf::rt::sint32_size(10, v);
        }
        if let Some(v) = self.redirect.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.backend_host.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.order != 0 {
            os.write_sint32(2, self.order)?;
        }
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.trigger_requirement.is_empty() {
            os.write_string(4, &self.trigger_requirement)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(Action::Monopoly) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if self.monopoly_action != ::protobuf::EnumOrUnknown::new(MonopolyAction::Block) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.monopoly_action))?;
        }
        for v in &self.trustbust_option {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.bucket_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.cache_level {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cache_ttl {
            os.write_sint32(10, v)?;
        }
        if let Some(v) = self.redirect.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.backend_host.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PageRule {
        PageRule::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.order = 0;
        self.matches.clear();
        self.trigger_requirement.clear();
        self.action = ::protobuf::EnumOrUnknown::new(Action::Monopoly);
        self.monopoly_action = ::protobuf::EnumOrUnknown::new(MonopolyAction::Block);
        self.trustbust_option.clear();
        self.bucket_name = ::std::option::Option::None;
        self.cache_level = ::std::option::Option::None;
        self.cache_ttl = ::std::option::Option::None;
        self.redirect = ::std::option::Option::None;
        self.backend_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PageRule {
        static instance: PageRule = PageRule {
            id: ::std::string::String::new(),
            order: 0,
            matches: ::std::vec::Vec::new(),
            trigger_requirement: ::std::string::String::new(),
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            monopoly_action: ::protobuf::EnumOrUnknown::from_i32(0),
            trustbust_option: ::std::vec::Vec::new(),
            bucket_name: ::std::option::Option::None,
            cache_level: ::std::option::Option::None,
            cache_ttl: ::std::option::Option::None,
            redirect: ::std::option::Option::None,
            backend_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PageRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PageRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PageRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PageRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.Match)
pub struct Match {
    // message fields
    // @@protoc_insertion_point(field:all.Match.trigger_type)
    pub trigger_type: ::protobuf::EnumOrUnknown<TriggerType>,
    // @@protoc_insertion_point(field:all.Match.match_type)
    pub match_type: ::protobuf::EnumOrUnknown<MatchType>,
    // @@protoc_insertion_point(field:all.Match.pure_string)
    pub pure_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:all.Match.key_value)
    pub key_value: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  special options
    // @@protoc_insertion_point(field:all.Match.inversed)
    pub inversed: bool,
    // @@protoc_insertion_point(field:all.Match.required)
    pub required: bool,
    // special fields
    // @@protoc_insertion_point(special_field:all.Match.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Match {
    fn default() -> &'a Match {
        <Match as ::protobuf::Message>::default_instance()
    }
}

impl Match {
    pub fn new() -> Match {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trigger_type",
            |m: &Match| { &m.trigger_type },
            |m: &mut Match| { &mut m.trigger_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "match_type",
            |m: &Match| { &m.match_type },
            |m: &mut Match| { &mut m.match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pure_string",
            |m: &Match| { &m.pure_string },
            |m: &mut Match| { &mut m.pure_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "key_value",
            |m: &Match| { &m.key_value },
            |m: &mut Match| { &mut m.key_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inversed",
            |m: &Match| { &m.inversed },
            |m: &mut Match| { &mut m.inversed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "required",
            |m: &Match| { &m.required },
            |m: &mut Match| { &mut m.required },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Match>(
            "Match",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Match {
    const NAME: &'static str = "Match";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trigger_type = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.match_type = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.pure_string = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.key_value.insert(key, value);
                },
                40 => {
                    self.inversed = is.read_bool()?;
                },
                48 => {
                    self.required = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.trigger_type != ::protobuf::EnumOrUnknown::new(TriggerType::Ip) {
            my_size += ::protobuf::rt::int32_size(1, self.trigger_type.value());
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(MatchType::Exact) {
            my_size += ::protobuf::rt::int32_size(2, self.match_type.value());
        }
        if let Some(v) = self.pure_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for (k, v) in &self.key_value {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.inversed != false {
            my_size += 1 + 1;
        }
        if self.required != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.trigger_type != ::protobuf::EnumOrUnknown::new(TriggerType::Ip) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.trigger_type))?;
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(MatchType::Exact) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.match_type))?;
        }
        if let Some(v) = self.pure_string.as_ref() {
            os.write_string(3, v)?;
        }
        for (k, v) in &self.key_value {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.inversed != false {
            os.write_bool(5, self.inversed)?;
        }
        if self.required != false {
            os.write_bool(6, self.required)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Match {
        Match::new()
    }

    fn clear(&mut self) {
        self.trigger_type = ::protobuf::EnumOrUnknown::new(TriggerType::Ip);
        self.match_type = ::protobuf::EnumOrUnknown::new(MatchType::Exact);
        self.pure_string = ::std::option::Option::None;
        self.key_value.clear();
        self.inversed = false;
        self.required = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Match {
        static instance: ::protobuf::rt::Lazy<Match> = ::protobuf::rt::Lazy::new();
        instance.get(Match::new)
    }
}

impl ::protobuf::MessageFull for Match {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Match").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Match {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  INTERNAL SETTINGS
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:all.InternalSettings)
pub struct InternalSettings {
    // message fields
    // @@protoc_insertion_point(field:all.InternalSettings.can_cache)
    pub can_cache: bool,
    // @@protoc_insertion_point(field:all.InternalSettings.domain_blocked)
    pub domain_blocked: bool,
    // @@protoc_insertion_point(field:all.InternalSettings.request_timeout)
    pub request_timeout: i32,
    // @@protoc_insertion_point(field:all.InternalSettings.threat_score_threshold)
    pub threat_score_threshold: i32,
    // @@protoc_insertion_point(field:all.InternalSettings.expected_passed)
    pub expected_passed: i32,
    ///  bytes / 1000
    // @@protoc_insertion_point(field:all.InternalSettings.cache_file_max)
    pub cache_file_max: i32,
    // @@protoc_insertion_point(field:all.InternalSettings.total_cache_limit)
    pub total_cache_limit: i32,
    // @@protoc_insertion_point(field:all.InternalSettings.allowed_open_conns)
    pub allowed_open_conns: i32,
    // @@protoc_insertion_point(field:all.InternalSettings.server_messages_threshold)
    pub server_messages_threshold: i32,
    // @@protoc_insertion_point(field:all.InternalSettings.allowed_ws_messages)
    pub allowed_ws_messages: i32,
    // special fields
    // @@protoc_insertion_point(special_field:all.InternalSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InternalSettings {
    fn default() -> &'a InternalSettings {
        <InternalSettings as ::protobuf::Message>::default_instance()
    }
}

impl InternalSettings {
    pub fn new() -> InternalSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_cache",
            |m: &InternalSettings| { &m.can_cache },
            |m: &mut InternalSettings| { &mut m.can_cache },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain_blocked",
            |m: &InternalSettings| { &m.domain_blocked },
            |m: &mut InternalSettings| { &mut m.domain_blocked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_timeout",
            |m: &InternalSettings| { &m.request_timeout },
            |m: &mut InternalSettings| { &mut m.request_timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threat_score_threshold",
            |m: &InternalSettings| { &m.threat_score_threshold },
            |m: &mut InternalSettings| { &mut m.threat_score_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expected_passed",
            |m: &InternalSettings| { &m.expected_passed },
            |m: &mut InternalSettings| { &mut m.expected_passed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cache_file_max",
            |m: &InternalSettings| { &m.cache_file_max },
            |m: &mut InternalSettings| { &mut m.cache_file_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_cache_limit",
            |m: &InternalSettings| { &m.total_cache_limit },
            |m: &mut InternalSettings| { &mut m.total_cache_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowed_open_conns",
            |m: &InternalSettings| { &m.allowed_open_conns },
            |m: &mut InternalSettings| { &mut m.allowed_open_conns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_messages_threshold",
            |m: &InternalSettings| { &m.server_messages_threshold },
            |m: &mut InternalSettings| { &mut m.server_messages_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowed_ws_messages",
            |m: &InternalSettings| { &m.allowed_ws_messages },
            |m: &mut InternalSettings| { &mut m.allowed_ws_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InternalSettings>(
            "InternalSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InternalSettings {
    const NAME: &'static str = "InternalSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.can_cache = is.read_bool()?;
                },
                24 => {
                    self.domain_blocked = is.read_bool()?;
                },
                32 => {
                    self.request_timeout = is.read_sint32()?;
                },
                40 => {
                    self.threat_score_threshold = is.read_sint32()?;
                },
                48 => {
                    self.expected_passed = is.read_sint32()?;
                },
                56 => {
                    self.cache_file_max = is.read_sint32()?;
                },
                64 => {
                    self.total_cache_limit = is.read_sint32()?;
                },
                72 => {
                    self.allowed_open_conns = is.read_sint32()?;
                },
                80 => {
                    self.server_messages_threshold = is.read_sint32()?;
                },
                88 => {
                    self.allowed_ws_messages = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.can_cache != false {
            my_size += 1 + 1;
        }
        if self.domain_blocked != false {
            my_size += 1 + 1;
        }
        if self.request_timeout != 0 {
            my_size += ::protobuf::rt::sint32_size(4, self.request_timeout);
        }
        if self.threat_score_threshold != 0 {
            my_size += ::protobuf::rt::sint32_size(5, self.threat_score_threshold);
        }
        if self.expected_passed != 0 {
            my_size += ::protobuf::rt::sint32_size(6, self.expected_passed);
        }
        if self.cache_file_max != 0 {
            my_size += ::protobuf::rt::sint32_size(7, self.cache_file_max);
        }
        if self.total_cache_limit != 0 {
            my_size += ::protobuf::rt::sint32_size(8, self.total_cache_limit);
        }
        if self.allowed_open_conns != 0 {
            my_size += ::protobuf::rt::sint32_size(9, self.allowed_open_conns);
        }
        if self.server_messages_threshold != 0 {
            my_size += ::protobuf::rt::sint32_size(10, self.server_messages_threshold);
        }
        if self.allowed_ws_messages != 0 {
            my_size += ::protobuf::rt::sint32_size(11, self.allowed_ws_messages);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.can_cache != false {
            os.write_bool(2, self.can_cache)?;
        }
        if self.domain_blocked != false {
            os.write_bool(3, self.domain_blocked)?;
        }
        if self.request_timeout != 0 {
            os.write_sint32(4, self.request_timeout)?;
        }
        if self.threat_score_threshold != 0 {
            os.write_sint32(5, self.threat_score_threshold)?;
        }
        if self.expected_passed != 0 {
            os.write_sint32(6, self.expected_passed)?;
        }
        if self.cache_file_max != 0 {
            os.write_sint32(7, self.cache_file_max)?;
        }
        if self.total_cache_limit != 0 {
            os.write_sint32(8, self.total_cache_limit)?;
        }
        if self.allowed_open_conns != 0 {
            os.write_sint32(9, self.allowed_open_conns)?;
        }
        if self.server_messages_threshold != 0 {
            os.write_sint32(10, self.server_messages_threshold)?;
        }
        if self.allowed_ws_messages != 0 {
            os.write_sint32(11, self.allowed_ws_messages)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InternalSettings {
        InternalSettings::new()
    }

    fn clear(&mut self) {
        self.can_cache = false;
        self.domain_blocked = false;
        self.request_timeout = 0;
        self.threat_score_threshold = 0;
        self.expected_passed = 0;
        self.cache_file_max = 0;
        self.total_cache_limit = 0;
        self.allowed_open_conns = 0;
        self.server_messages_threshold = 0;
        self.allowed_ws_messages = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InternalSettings {
        static instance: InternalSettings = InternalSettings {
            can_cache: false,
            domain_blocked: false,
            request_timeout: 0,
            threat_score_threshold: 0,
            expected_passed: 0,
            cache_file_max: 0,
            total_cache_limit: 0,
            allowed_open_conns: 0,
            server_messages_threshold: 0,
            allowed_ws_messages: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InternalSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InternalSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InternalSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.WsMethods)
pub enum WsMethods {
    // @@protoc_insertion_point(enum_value:all.WsMethods.Txt)
    Txt = 0,
    // @@protoc_insertion_point(enum_value:all.WsMethods.Ping)
    Ping = 1,
    // @@protoc_insertion_point(enum_value:all.WsMethods.Binary)
    Binary = 2,
    // @@protoc_insertion_point(enum_value:all.WsMethods.Close)
    Close = 3,
}

impl ::protobuf::Enum for WsMethods {
    const NAME: &'static str = "WsMethods";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WsMethods> {
        match value {
            0 => ::std::option::Option::Some(WsMethods::Txt),
            1 => ::std::option::Option::Some(WsMethods::Ping),
            2 => ::std::option::Option::Some(WsMethods::Binary),
            3 => ::std::option::Option::Some(WsMethods::Close),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WsMethods] = &[
        WsMethods::Txt,
        WsMethods::Ping,
        WsMethods::Binary,
        WsMethods::Close,
    ];
}

impl ::protobuf::EnumFull for WsMethods {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WsMethods").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WsMethods {
    fn default() -> Self {
        WsMethods::Txt
    }
}

impl WsMethods {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WsMethods>("WsMethods")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.WebMethods)
pub enum WebMethods {
    // @@protoc_insertion_point(enum_value:all.WebMethods.Get)
    Get = 0,
    // @@protoc_insertion_point(enum_value:all.WebMethods.Post)
    Post = 1,
    // @@protoc_insertion_point(enum_value:all.WebMethods.Options)
    Options = 2,
    // @@protoc_insertion_point(enum_value:all.WebMethods.Delete)
    Delete = 3,
}

impl ::protobuf::Enum for WebMethods {
    const NAME: &'static str = "WebMethods";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WebMethods> {
        match value {
            0 => ::std::option::Option::Some(WebMethods::Get),
            1 => ::std::option::Option::Some(WebMethods::Post),
            2 => ::std::option::Option::Some(WebMethods::Options),
            3 => ::std::option::Option::Some(WebMethods::Delete),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WebMethods] = &[
        WebMethods::Get,
        WebMethods::Post,
        WebMethods::Options,
        WebMethods::Delete,
    ];
}

impl ::protobuf::EnumFull for WebMethods {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WebMethods").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WebMethods {
    fn default() -> Self {
        WebMethods::Get
    }
}

impl WebMethods {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebMethods>("WebMethods")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.CacheLevel)
pub enum CacheLevel {
    // @@protoc_insertion_point(enum_value:all.CacheLevel.None)
    None = 0,
    // @@protoc_insertion_point(enum_value:all.CacheLevel.Standard)
    Standard = 1,
    // @@protoc_insertion_point(enum_value:all.CacheLevel.IgnoreQueryString)
    IgnoreQueryString = 2,
    // @@protoc_insertion_point(enum_value:all.CacheLevel.Aggressive)
    Aggressive = 3,
}

impl ::protobuf::Enum for CacheLevel {
    const NAME: &'static str = "CacheLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheLevel> {
        match value {
            0 => ::std::option::Option::Some(CacheLevel::None),
            1 => ::std::option::Option::Some(CacheLevel::Standard),
            2 => ::std::option::Option::Some(CacheLevel::IgnoreQueryString),
            3 => ::std::option::Option::Some(CacheLevel::Aggressive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CacheLevel] = &[
        CacheLevel::None,
        CacheLevel::Standard,
        CacheLevel::IgnoreQueryString,
        CacheLevel::Aggressive,
    ];
}

impl ::protobuf::EnumFull for CacheLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CacheLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CacheLevel {
    fn default() -> Self {
        CacheLevel::None
    }
}

impl CacheLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CacheLevel>("CacheLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.Bot)
pub enum Bot {
    // @@protoc_insertion_point(enum_value:all.Bot.Googlebot)
    Googlebot = 0,
    // @@protoc_insertion_point(enum_value:all.Bot.Bingbot)
    Bingbot = 1,
    // @@protoc_insertion_point(enum_value:all.Bot.UptimeRobot)
    UptimeRobot = 2,
}

impl ::protobuf::Enum for Bot {
    const NAME: &'static str = "Bot";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bot> {
        match value {
            0 => ::std::option::Option::Some(Bot::Googlebot),
            1 => ::std::option::Option::Some(Bot::Bingbot),
            2 => ::std::option::Option::Some(Bot::UptimeRobot),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bot] = &[
        Bot::Googlebot,
        Bot::Bingbot,
        Bot::UptimeRobot,
    ];
}

impl ::protobuf::EnumFull for Bot {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Bot").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Bot {
    fn default() -> Self {
        Bot::Googlebot
    }
}

impl Bot {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Bot>("Bot")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.TriggerType)
pub enum TriggerType {
    // @@protoc_insertion_point(enum_value:all.TriggerType.Ip)
    Ip = 0,
    // @@protoc_insertion_point(enum_value:all.TriggerType.Path)
    Path = 1,
    // @@protoc_insertion_point(enum_value:all.TriggerType.Query)
    Query = 2,
    // @@protoc_insertion_point(enum_value:all.TriggerType.Asn)
    Asn = 3,
    // @@protoc_insertion_point(enum_value:all.TriggerType.Country)
    Country = 4,
    // @@protoc_insertion_point(enum_value:all.TriggerType.Continent)
    Continent = 5,
    // @@protoc_insertion_point(enum_value:all.TriggerType.Headers)
    Headers = 6,
}

impl ::protobuf::Enum for TriggerType {
    const NAME: &'static str = "TriggerType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TriggerType> {
        match value {
            0 => ::std::option::Option::Some(TriggerType::Ip),
            1 => ::std::option::Option::Some(TriggerType::Path),
            2 => ::std::option::Option::Some(TriggerType::Query),
            3 => ::std::option::Option::Some(TriggerType::Asn),
            4 => ::std::option::Option::Some(TriggerType::Country),
            5 => ::std::option::Option::Some(TriggerType::Continent),
            6 => ::std::option::Option::Some(TriggerType::Headers),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TriggerType] = &[
        TriggerType::Ip,
        TriggerType::Path,
        TriggerType::Query,
        TriggerType::Asn,
        TriggerType::Country,
        TriggerType::Continent,
        TriggerType::Headers,
    ];
}

impl ::protobuf::EnumFull for TriggerType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TriggerType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TriggerType {
    fn default() -> Self {
        TriggerType::Ip
    }
}

impl TriggerType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TriggerType>("TriggerType")
    }
}

///  can be shared for API engine as well
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.MatchType)
pub enum MatchType {
    // @@protoc_insertion_point(enum_value:all.MatchType.Exact)
    Exact = 0,
    // @@protoc_insertion_point(enum_value:all.MatchType.Contains)
    Contains = 1,
    // @@protoc_insertion_point(enum_value:all.MatchType.StartsWith)
    StartsWith = 2,
}

impl ::protobuf::Enum for MatchType {
    const NAME: &'static str = "MatchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchType::Exact),
            1 => ::std::option::Option::Some(MatchType::Contains),
            2 => ::std::option::Option::Some(MatchType::StartsWith),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchType] = &[
        MatchType::Exact,
        MatchType::Contains,
        MatchType::StartsWith,
    ];
}

impl ::protobuf::EnumFull for MatchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MatchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MatchType {
    fn default() -> Self {
        MatchType::Exact
    }
}

impl MatchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatchType>("MatchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.Action)
pub enum Action {
    // @@protoc_insertion_point(enum_value:all.Action.Monopoly)
    Monopoly = 0,
    // @@protoc_insertion_point(enum_value:all.Action.Trustbusting)
    Trustbusting = 1,
}

impl ::protobuf::Enum for Action {
    const NAME: &'static str = "Action";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Action> {
        match value {
            0 => ::std::option::Option::Some(Action::Monopoly),
            1 => ::std::option::Option::Some(Action::Trustbusting),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Action] = &[
        Action::Monopoly,
        Action::Trustbusting,
    ];
}

impl ::protobuf::EnumFull for Action {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Action").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Action {
    fn default() -> Self {
        Action::Monopoly
    }
}

impl Action {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Action>("Action")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.MonopolyAction)
pub enum MonopolyAction {
    // @@protoc_insertion_point(enum_value:all.MonopolyAction.Block)
    Block = 0,
}

impl ::protobuf::Enum for MonopolyAction {
    const NAME: &'static str = "MonopolyAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MonopolyAction> {
        match value {
            0 => ::std::option::Option::Some(MonopolyAction::Block),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MonopolyAction] = &[
        MonopolyAction::Block,
    ];
}

impl ::protobuf::EnumFull for MonopolyAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MonopolyAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MonopolyAction {
    fn default() -> Self {
        MonopolyAction::Block
    }
}

impl MonopolyAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MonopolyAction>("MonopolyAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:all.TrustBustOption)
pub enum TrustBustOption {
    // @@protoc_insertion_point(enum_value:all.TrustBustOption.SmartChallenge)
    SmartChallenge = 0,
    // @@protoc_insertion_point(enum_value:all.TrustBustOption.CaptchaChallenge)
    CaptchaChallenge = 1,
    // @@protoc_insertion_point(enum_value:all.TrustBustOption.RatelimitBucket)
    RatelimitBucket = 2,
    // @@protoc_insertion_point(enum_value:all.TrustBustOption.Cache)
    Cache = 3,
    // @@protoc_insertion_point(enum_value:all.TrustBustOption.Redirect)
    Redirect = 4,
    // @@protoc_insertion_point(enum_value:all.TrustBustOption.UseBackend)
    UseBackend = 5,
}

impl ::protobuf::Enum for TrustBustOption {
    const NAME: &'static str = "TrustBustOption";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrustBustOption> {
        match value {
            0 => ::std::option::Option::Some(TrustBustOption::SmartChallenge),
            1 => ::std::option::Option::Some(TrustBustOption::CaptchaChallenge),
            2 => ::std::option::Option::Some(TrustBustOption::RatelimitBucket),
            3 => ::std::option::Option::Some(TrustBustOption::Cache),
            4 => ::std::option::Option::Some(TrustBustOption::Redirect),
            5 => ::std::option::Option::Some(TrustBustOption::UseBackend),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrustBustOption] = &[
        TrustBustOption::SmartChallenge,
        TrustBustOption::CaptchaChallenge,
        TrustBustOption::RatelimitBucket,
        TrustBustOption::Cache,
        TrustBustOption::Redirect,
        TrustBustOption::UseBackend,
    ];
}

impl ::protobuf::EnumFull for TrustBustOption {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrustBustOption").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrustBustOption {
    fn default() -> Self {
        TrustBustOption::SmartChallenge
    }
}

impl TrustBustOption {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrustBustOption>("TrustBustOption")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tall.proto\x12\x03all\"C\n\rQueryResponse\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\"H\n\x0fAllDomainSchema\x125\n\neverything\x18\x01\x20\x03(\
    \x0b2\x15.all.FullDomainSchemaR\neverything\"\xc2\x05\n\x13PartialDomain\
    Schema\x12\x16\n\x06domain\x18\x01\x20\x01(\tR\x06domain\x12U\n\x0forigi\
    n_settings\x18\x02\x20\x03(\x0b2,.all.PartialDomainSchema.OriginSettings\
    EntryR\x0eoriginSettings\x12K\n\x13api_engine_settings\x18\x03\x20\x01(\
    \x0b2\x16.all.ApiEngineSettingsH\0R\x11apiEngineSettings\x88\x01\x01\x12\
    8\n\x0cbot_settings\x18\x04\x20\x01(\x0b2\x10.all.BotSettingsH\x01R\x0bb\
    otSettings\x88\x01\x01\x12@\n\x0ecache_settings\x18\x05\x20\x01(\x0b2\
    \x14.all.CachingSettingsH\x02R\rcacheSettings\x88\x01\x01\x122\n\x07buck\
    ets\x18\x06\x20\x01(\x0b2\x13.all.BucketSettingsH\x03R\x07buckets\x88\
    \x01\x01\x122\n\npage_rules\x18\x07\x20\x01(\x0b2\x0e.all.PageRulesH\x04\
    R\tpageRules\x88\x01\x01\x12G\n\x11internal_settings\x18\x08\x20\x01(\
    \x0b2\x15.all.InternalSettingsH\x05R\x10internalSettings\x88\x01\x01\x1a\
    U\n\x13OriginSettingsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.all.OriginSettingR\x05value:\
    \x028\x01B\x16\n\x14_api_engine_settingsB\x0f\n\r_bot_settingsB\x11\n\
    \x0f_cache_settingsB\n\n\x08_bucketsB\r\n\x0b_page_rulesB\x14\n\x12_inte\
    rnal_settings\"\xfc\x03\n\x10FullDomainSchema\x12\x16\n\x06domain\x18\
    \x01\x20\x01(\tR\x06domain\x12R\n\x0forigin_settings\x18\x02\x20\x03(\
    \x0b2).all.FullDomainSchema.OriginSettingsEntryR\x0eoriginSettings\x12F\
    \n\x13api_engine_settings\x18\x03\x20\x01(\x0b2\x16.all.ApiEngineSetting\
    sR\x11apiEngineSettings\x12;\n\x0ecache_settings\x18\x04\x20\x01(\x0b2\
    \x14.all.CachingSettingsR\rcacheSettings\x12-\n\x07buckets\x18\x05\x20\
    \x01(\x0b2\x13.all.BucketSettingsR\x07buckets\x12-\n\npage_rules\x18\x06\
    \x20\x01(\x0b2\x0e.all.PageRulesR\tpageRules\x12B\n\x11internal_settings\
    \x18\x07\x20\x01(\x0b2\x15.all.InternalSettingsR\x10internalSettings\x1a\
    U\n\x13OriginSettingsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.all.OriginSettingR\x05value:\
    \x028\x01\",\n\x12DeleteDomainSchema\x12\x16\n\x06domain\x18\x01\x20\x01\
    (\tR\x06domain\"\xa5\x01\n\rOriginSetting\x12\x12\n\x04host\x18\x01\x20\
    \x01(\tR\x04host\x12\x10\n\x03ssl\x18\x02\x20\x01(\x08R\x03ssl\x12\x14\n\
    \x05http2\x18\x03\x20\x01(\x08R\x05http2\x12\x18\n\x07timeout\x18\x04\
    \x20\x01(\x11R\x07timeout\x12\x17\n\x07ip_data\x18\x06\x20\x01(\x08R\x06\
    ipData\x12%\n\x07origins\x18\x07\x20\x03(\x0b2\x0b.all.OriginR\x07origin\
    s\"2\n\x06Origin\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x16\n\
    \x06weight\x18\x02\x20\x01(\x11R\x06weight\"\xc3\x01\n\x11ApiEngineSetti\
    ngs\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12@\n\x08sett\
    ings\x18\x02\x20\x03(\x0b2$.all.ApiEngineSettings.SettingsEntryR\x08sett\
    ings\x1aR\n\rSettingsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12+\n\x05value\x18\x02\x20\x01(\x0b2\x15.all.ApiEngineSettingR\x05valu\
    e:\x028\x01\"\xf6\x01\n\x10ApiEngineSetting\x12_\n\x14kv_whitelist_facto\
    rs\x18\x01\x20\x03(\x0b2-.all.ApiEngineSetting.KvWhitelistFactorsEntryR\
    \x12kvWhitelistFactors\x12\x10\n\x03ips\x18\x02\x20\x03(\tR\x03ips\x12(\
    \n\x05rules\x18\x03\x20\x03(\x0b2\x12.all.ApiEngineRuleR\x05rules\x1aE\n\
    \x17KvWhitelistFactorsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc2\x03\n\r\
    ApiEngineRule\x12\x1a\n\x08position\x18\x01\x20\x01(\x11R\x08position\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12-\n\nmatch_type\x18\
    \x03\x20\x01(\x0e2\x0e.all.MatchTypeR\tmatchType\x12,\n\x12allow_query_s\
    tring\x18\x04\x20\x01(\x08R\x10allowQueryString\x12-\n\nws_methods\x18\
    \x05\x20\x03(\x0e2\x0e.all.WsMethodsR\twsMethods\x120\n\x0bweb_methods\
    \x18\x06\x20\x03(\x0e2\x0f.all.WebMethodsR\nwebMethods\x124\n\x13ratelim\
    iting_bucket\x18\x07\x20\x01(\tH\0R\x12ratelimitingBucket\x88\x01\x01\
    \x12$\n\x0bcache_level\x18\x08\x20\x01(\tH\x01R\ncacheLevel\x88\x01\x01\
    \x12+\n\x0fcache_level_ttl\x18\t\x20\x01(\x11H\x02R\rcacheLevelTtl\x88\
    \x01\x01B\x16\n\x14_ratelimiting_bucketB\x0e\n\x0c_cache_levelB\x12\n\
    \x10_cache_level_ttl\"\x93\x01\n\x0fCachingSettings\x12\x18\n\x07enabled\
    \x18\x01\x20\x01(\x08R\x07enabled\x120\n\x0bcache_level\x18\x02\x20\x01(\
    \x0e2\x0f.all.CacheLevelR\ncacheLevel\x12$\n\x0bdefault_ttl\x18\x03\x20\
    \x01(\x11H\0R\ndefaultTtl\x88\x01\x01B\x0e\n\x0c_default_ttl\"E\n\x0bBot\
    Settings\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\x1c\n\
    \x04bots\x18\x02\x20\x03(\x0e2\x08.all.BotR\x04bots\"7\n\x0eBucketSettin\
    gs\x12%\n\x07buckets\x18\x01\x20\x03(\x0b2\x0b.all.BucketR\x07buckets\"@\
    \n\x06Bucket\x12\x1c\n\tthreshold\x18\x01\x20\x01(\x11R\tthreshold\x12\
    \x18\n\x07timeout\x18\x02\x20\x01(\x11R\x07timeout\"J\n\tPageRules\x12\
    \x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12#\n\x05rules\x18\
    \x02\x20\x03(\x0b2\r.all.PageRuleR\x05rules\"\xbf\x04\n\x08PageRule\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05order\x18\x02\x20\
    \x01(\x11R\x05order\x12$\n\x07matches\x18\x03\x20\x03(\x0b2\n.all.MatchR\
    \x07matches\x12/\n\x13trigger_requirement\x18\x04\x20\x01(\tR\x12trigger\
    Requirement\x12#\n\x06action\x18\x05\x20\x01(\x0e2\x0b.all.ActionR\x06ac\
    tion\x12<\n\x0fmonopoly_action\x18\x06\x20\x01(\x0e2\x13.all.MonopolyAct\
    ionR\x0emonopolyAction\x12?\n\x10trustbust_option\x18\x07\x20\x03(\x0e2\
    \x14.all.TrustBustOptionR\x0ftrustbustOption\x12$\n\x0bbucket_name\x18\
    \x08\x20\x01(\tH\0R\nbucketName\x88\x01\x01\x125\n\x0bcache_level\x18\t\
    \x20\x01(\x0e2\x0f.all.CacheLevelH\x01R\ncacheLevel\x88\x01\x01\x12\x20\
    \n\tcache_ttl\x18\n\x20\x01(\x11H\x02R\x08cacheTtl\x88\x01\x01\x12\x1f\n\
    \x08redirect\x18\x0b\x20\x01(\tH\x03R\x08redirect\x88\x01\x01\x12&\n\x0c\
    backend_host\x18\x0c\x20\x01(\tH\x04R\x0bbackendHost\x88\x01\x01B\x0e\n\
    \x0c_bucket_nameB\x0e\n\x0c_cache_levelB\x0c\n\n_cache_ttlB\x0b\n\t_redi\
    rectB\x0f\n\r_backend_host\"\xcd\x02\n\x05Match\x123\n\x0ctrigger_type\
    \x18\x01\x20\x01(\x0e2\x10.all.TriggerTypeR\x0btriggerType\x12-\n\nmatch\
    _type\x18\x02\x20\x01(\x0e2\x0e.all.MatchTypeR\tmatchType\x12$\n\x0bpure\
    _string\x18\x03\x20\x01(\tH\0R\npureString\x88\x01\x01\x125\n\tkey_value\
    \x18\x04\x20\x03(\x0b2\x18.all.Match.KeyValueEntryR\x08keyValue\x12\x1a\
    \n\x08inversed\x18\x05\x20\x01(\x08R\x08inversed\x12\x1a\n\x08required\
    \x18\x06\x20\x01(\x08R\x08required\x1a;\n\rKeyValueEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01B\x0e\n\x0c_pure_string\"\xca\x03\n\x10InternalSettings\
    \x12\x1b\n\tcan_cache\x18\x02\x20\x01(\x08R\x08canCache\x12%\n\x0edomain\
    _blocked\x18\x03\x20\x01(\x08R\rdomainBlocked\x12'\n\x0frequest_timeout\
    \x18\x04\x20\x01(\x11R\x0erequestTimeout\x124\n\x16threat_score_threshol\
    d\x18\x05\x20\x01(\x11R\x14threatScoreThreshold\x12'\n\x0fexpected_passe\
    d\x18\x06\x20\x01(\x11R\x0eexpectedPassed\x12$\n\x0ecache_file_max\x18\
    \x07\x20\x01(\x11R\x0ccacheFileMax\x12*\n\x11total_cache_limit\x18\x08\
    \x20\x01(\x11R\x0ftotalCacheLimit\x12,\n\x12allowed_open_conns\x18\t\x20\
    \x01(\x11R\x10allowedOpenConns\x12:\n\x19server_messages_threshold\x18\n\
    \x20\x01(\x11R\x17serverMessagesThreshold\x12.\n\x13allowed_ws_messages\
    \x18\x0b\x20\x01(\x11R\x11allowedWsMessages*5\n\tWsMethods\x12\x07\n\x03\
    Txt\x10\0\x12\x08\n\x04Ping\x10\x01\x12\n\n\x06Binary\x10\x02\x12\t\n\
    \x05Close\x10\x03*8\n\nWebMethods\x12\x07\n\x03Get\x10\0\x12\x08\n\x04Po\
    st\x10\x01\x12\x0b\n\x07Options\x10\x02\x12\n\n\x06Delete\x10\x03*K\n\nC\
    acheLevel\x12\x08\n\x04None\x10\0\x12\x0c\n\x08Standard\x10\x01\x12\x15\
    \n\x11IgnoreQueryString\x10\x02\x12\x0e\n\nAggressive\x10\x03*2\n\x03Bot\
    \x12\r\n\tGooglebot\x10\0\x12\x0b\n\x07Bingbot\x10\x01\x12\x0f\n\x0bUpti\
    meRobot\x10\x02*\\\n\x0bTriggerType\x12\x06\n\x02Ip\x10\0\x12\x08\n\x04P\
    ath\x10\x01\x12\t\n\x05Query\x10\x02\x12\x07\n\x03Asn\x10\x03\x12\x0b\n\
    \x07Country\x10\x04\x12\r\n\tContinent\x10\x05\x12\x0b\n\x07Headers\x10\
    \x06*4\n\tMatchType\x12\t\n\x05Exact\x10\0\x12\x0c\n\x08Contains\x10\x01\
    \x12\x0e\n\nStartsWith\x10\x02*(\n\x06Action\x12\x0c\n\x08Monopoly\x10\0\
    \x12\x10\n\x0cTrustbusting\x10\x01*\x1b\n\x0eMonopolyAction\x12\t\n\x05B\
    lock\x10\0*y\n\x0fTrustBustOption\x12\x12\n\x0eSmartChallenge\x10\0\x12\
    \x14\n\x10CaptchaChallenge\x10\x01\x12\x13\n\x0fRatelimitBucket\x10\x02\
    \x12\t\n\x05Cache\x10\x03\x12\x0c\n\x08Redirect\x10\x04\x12\x0e\n\nUseBa\
    ckend\x10\x052\xf5\x01\n\tBigBaller\x126\n\nAllDomains\x12\x14.all.AllDo\
    mainSchema\x1a\x12.all.QueryResponse\x12<\n\x0cUpdateDomain\x12\x18.all.\
    PartialDomainSchema\x1a\x12.all.QueryResponse\x125\n\tNewDomain\x12\x14.\
    all.AllDomainSchema\x1a\x12.all.QueryResponse\x12;\n\x0cDeleteDomain\x12\
    \x17.all.DeleteDomainSchema\x1a\x12.all.QueryResponseJ\x8eD\n\x07\x12\
    \x05\x04\0\xf8\x01\x01\n{\n\x01\x0c\x12\x03\x04\0\x122H\x20we\x20have\
    \x20to\x20send\x20all\x20domain\x20information\x20to\x20the\x20server\
    \x20on\x20startup!\x20TODO!\n2'\x20this\x20should\x20be\x20absolutely\
    \x20everything!\n\n\x08\n\x01\x02\x12\x03\x06\0\x0c\n\n\n\x02\x06\0\x12\
    \x04\x08\0\x11\x01\n\n\n\x03\x06\0\x01\x12\x03\x08\x08\x11\n7\n\x04\x06\
    \0\x02\0\x12\x03\n\x02:\x1a*\x20on\x20startup\x20message,\x20includes\
    \x20all\x20domains\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\n\x06\x10\n\x0c\
    \n\x05\x06\0\x02\0\x02\x12\x03\n\x11\x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\
    \x03\n+8\nL\n\x04\x06\0\x02\x01\x12\x03\x0c\x02@\x1a?\x20update\x20domai\
    n\x20after\x20the\x20user,\x20or\x20an\x20admin,\x20makes\x20some\x20cha\
    nges\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x0c\x06\x12\n\x0c\n\x05\x06\
    \0\x02\x01\x02\x12\x03\x0c\x13&\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\
    \x0c1>\n(\n\x04\x06\0\x02\x02\x12\x03\x0e\x029\x1a\x1b\x20new\x20domain\
    \x20on\x20our\x20service\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x0e\x06\
    \x0f\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x0e\x10\x1f\n\x0c\n\x05\x06\0\
    \x02\x02\x03\x12\x03\x0e*7\n1\n\x04\x06\0\x02\x03\x12\x03\x10\x02?\x1a$\
    \x20deleting\x20a\x20domain\x20from\x20our\x20service\n\n\x0c\n\x05\x06\
    \0\x02\x03\x01\x12\x03\x10\x06\x12\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\
    \x10\x13%\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x100=\n\x1d\n\x02\x04\0\
    \x12\x04\x14\0\x17\x01\x1a\x11\x20THE\x20MAIN\x20THINGS\n\n\n\n\x03\x04\
    \0\x01\x12\x03\x14\x08\x15\n\x0b\n\x04\x04\0\x02\0\x12\x03\x15\x02\x13\n\
    \x0c\n\x05\x04\0\x02\0\x05\x12\x03\x15\x02\x06\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x15\x07\x0e\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x15\x11\x12\
    \n\x0b\n\x04\x04\0\x02\x01\x12\x03\x16\x02\x15\n\x0c\n\x05\x04\0\x02\x01\
    \x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x16\t\x10\
    \n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x16\x13\x14\n\n\n\x02\x04\x01\x12\
    \x04\x19\0\x1b\x01\n\n\n\x03\x04\x01\x01\x12\x03\x19\x08\x17\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03\x1a\x02+\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\
    \x1a\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x1a\x0b\x1b\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03\x1a\x1c&\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03\x1a)*\nG\n\x02\x04\x02\x12\x04\x1e\0'\x01\x1a;\x20for\x20when\x20a\
    \x20domain\x20is\x20updated,\x20only\x20the\x20difference\x20is\x20sent\
    \n\n\n\n\x03\x04\x02\x01\x12\x03\x1e\x08\x1b\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03\x1f\x02\x14\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x1f\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1f\t\x0f\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03\x1f\x12\x13\nA\n\x04\x04\x02\x02\x01\x12\x03\x20\x021\"4\
    \x20if\x20this\x20isn't\x20part\x20of\x20it,\x20then\x20it'll\x20just\
    \x20be\x20empty\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03\x20\x02\x1c\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x20\x1d,\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03\x20/0\n\x0b\n\x04\x04\x02\x02\x02\x12\x03!\x025\n\x0c\n\
    \x05\x04\x02\x02\x02\x04\x12\x03!\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x06\
    \x12\x03!\x0b\x1c\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03!\x1d0\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x03!34\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\
    \"\x02(\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03\"\x02\n\n\x0c\n\x05\x04\
    \x02\x02\x03\x06\x12\x03\"\x0b\x16\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\
    \x03\"\x17#\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\"&'\n\x0b\n\x04\x04\
    \x02\x02\x04\x12\x03#\x02.\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03#\x02\
    \n\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03#\x0b\x1a\n\x0c\n\x05\x04\x02\
    \x02\x04\x01\x12\x03#\x1b)\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03#,-\n\
    \x0b\n\x04\x04\x02\x02\x05\x12\x03$\x02&\n\x0c\n\x05\x04\x02\x02\x05\x04\
    \x12\x03$\x02\n\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x03$\x0b\x19\n\x0c\n\
    \x05\x04\x02\x02\x05\x01\x12\x03$\x1a!\n\x0c\n\x05\x04\x02\x02\x05\x03\
    \x12\x03$$%\n\x0b\n\x04\x04\x02\x02\x06\x12\x03%\x02$\n\x0c\n\x05\x04\
    \x02\x02\x06\x04\x12\x03%\x02\n\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03%\
    \x0b\x14\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03%\x15\x1f\n\x0c\n\x05\
    \x04\x02\x02\x06\x03\x12\x03%\"#\n\x0b\n\x04\x04\x02\x02\x07\x12\x03&\
    \x022\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03&\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x07\x06\x12\x03&\x0b\x1b\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03&\
    \x1c-\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03&01\n\n\n\x02\x04\x03\x12\
    \x04)\01\x01\n\n\n\x03\x04\x03\x01\x12\x03)\x08\x18\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03*\x02\x14\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03*\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03*\t\x0f\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03*\x12\x13\n\x0b\n\x04\x04\x03\x02\x01\x12\x03+\x021\n\x0c\n\
    \x05\x04\x03\x02\x01\x06\x12\x03+\x02\x1c\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03+\x1d,\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03+/0\n\x0b\n\
    \x04\x04\x03\x02\x02\x12\x03,\x02,\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\
    \x03,\x02\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03,\x14'\n\x0c\n\x05\
    \x04\x03\x02\x02\x03\x12\x03,*+\n\x0b\n\x04\x04\x03\x02\x03\x12\x03-\x02\
    %\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x03-\x02\x11\n\x0c\n\x05\x04\x03\
    \x02\x03\x01\x12\x03-\x12\x20\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03-#$\
    \n\x0b\n\x04\x04\x03\x02\x04\x12\x03.\x02\x1d\n\x0c\n\x05\x04\x03\x02\
    \x04\x06\x12\x03.\x02\x10\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03.\x11\
    \x18\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03.\x1b\x1c\n\x0b\n\x04\x04\
    \x03\x02\x05\x12\x03/\x02\x1b\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\x03/\
    \x02\x0b\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03/\x0c\x16\n\x0c\n\x05\
    \x04\x03\x02\x05\x03\x12\x03/\x19\x1a\n\x0b\n\x04\x04\x03\x02\x06\x12\
    \x030\x02)\n\x0c\n\x05\x04\x03\x02\x06\x06\x12\x030\x02\x12\n\x0c\n\x05\
    \x04\x03\x02\x06\x01\x12\x030\x13$\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\
    \x030'(\n\n\n\x02\x04\x04\x12\x043\05\x01\n\n\n\x03\x04\x04\x01\x12\x033\
    \x08\x1a\n\x0b\n\x04\x04\x04\x02\0\x12\x034\x02\x14\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x034\t\x0f\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x034\x12\x13\n0\n\x02\x04\x05\x12\x04\
    :\0C\x01\x1a\t\x20ORIGINS\n2\x19\x20EVERYTHING\x20THAT\x20FOLLOWS\n\n\n\
    \n\x03\x04\x05\x01\x12\x03:\x08\x15\n\x0b\n\x04\x04\x05\x02\0\x12\x03;\
    \x02\x12\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03;\t\r\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03;\x10\
    \x11\n\x0b\n\x04\x04\x05\x02\x01\x12\x03<\x02\x0f\n\x0c\n\x05\x04\x05\
    \x02\x01\x05\x12\x03<\x02\x06\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03<\
    \x07\n\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03<\r\x0e\n\x0b\n\x04\x04\
    \x05\x02\x02\x12\x03=\x02\x11\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03=\
    \x02\x06\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03=\x07\x0c\n\x0c\n\x05\
    \x04\x05\x02\x02\x03\x12\x03=\x0f\x10\n\x0b\n\x04\x04\x05\x02\x03\x12\
    \x03>\x02\x15\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03>\x02\x08\n\x0c\n\
    \x05\x04\x05\x02\x03\x01\x12\x03>\t\x10\n\x0c\n\x05\x04\x05\x02\x03\x03\
    \x12\x03>\x13\x14\n\x0b\n\x04\x04\x05\x02\x04\x12\x03?\x02\x13\n\x0c\n\
    \x05\x04\x05\x02\x04\x05\x12\x03?\x02\x06\n\x0c\n\x05\x04\x05\x02\x04\
    \x01\x12\x03?\x07\x0e\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03?\x11\x12\n\
    !\n\x04\x04\x05\x02\x05\x12\x03B\x02\x1e\x1a\x14\x20origins\x20themselve\
    s\n\n\x0c\n\x05\x04\x05\x02\x05\x04\x12\x03B\x02\n\n\x0c\n\x05\x04\x05\
    \x02\x05\x06\x12\x03B\x0b\x11\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03B\
    \x12\x19\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03B\x1c\x1d\n\n\n\x02\x04\
    \x06\x12\x04E\0H\x01\n\n\n\x03\x04\x06\x01\x12\x03E\x08\x0e\n\x0b\n\x04\
    \x04\x06\x02\0\x12\x03F\x02\x11\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03F\
    \x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03F\t\x0c\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x03F\x0f\x10\n\x0b\n\x04\x04\x06\x02\x01\x12\x03G\x02\
    \x14\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03G\t\x0f\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03G\
    \x12\x13\n\x18\n\x02\x04\x07\x12\x04L\0O\x01\x1a\x0c\x20API\x20ENGINE\n\
    \n\n\n\x03\x04\x07\x01\x12\x03L\x08\x19\n\x0b\n\x04\x04\x07\x02\0\x12\
    \x03M\x02\x13\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03M\x02\x06\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03M\x07\x0e\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03M\x11\x12\n-\n\x04\x04\x07\x02\x01\x12\x03N\x02-\"\x20\x20key\x20\"b\
    ase\"\x20path\x20TODO\x20respect\x20*\n\n\x0c\n\x05\x04\x07\x02\x01\x06\
    \x12\x03N\x02\x1f\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03N\x20(\n\x0c\n\
    \x05\x04\x07\x02\x01\x03\x12\x03N+,\n\n\n\x02\x04\x08\x12\x04Q\0V\x01\n\
    \n\n\x03\x04\x08\x01\x12\x03Q\x08\x18\n?\n\x04\x04\x08\x02\0\x12\x03R\
    \x02/\"2\x20key_value\x20header\x20whitelist\x20factors\x20for\x20this\
    \x20path\n\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03R\x02\x15\n\x0c\n\x05\
    \x04\x08\x02\0\x01\x12\x03R\x16*\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03R-\
    .\n\x0b\n\x04\x04\x08\x02\x01\x12\x03S\x02\x1a\n\x0c\n\x05\x04\x08\x02\
    \x01\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03S\x0b\x11\
    \n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03S\x12\x15\n\x0c\n\x05\x04\x08\
    \x02\x01\x03\x12\x03S\x18\x19\n\x0b\n\x04\x04\x08\x02\x02\x12\x03U\x02#\
    \n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\x08\x02\
    \x02\x06\x12\x03U\x0b\x18\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03U\x19\
    \x1e\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03U!\"\n\n\n\x02\x04\t\x12\x04\
    X\0d\x01\n\n\n\x03\x04\t\x01\x12\x03X\x08\x15\n\x0b\n\x04\x04\t\x02\0\
    \x12\x03Y\x02\x16\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03Y\x02\x08\n\x0c\n\
    \x05\x04\t\x02\0\x01\x12\x03Y\t\x11\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03Y\
    \x14\x15\n\x0b\n\x04\x04\t\x02\x01\x12\x03Z\x02\x12\n\x0c\n\x05\x04\t\
    \x02\x01\x05\x12\x03Z\x02\x08\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03Z\t\r\
    \n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03Z\x10\x11\n:\n\x04\x04\t\x02\x02\
    \x12\x03[\x02\x1b\"-\x20either\x20\"Exact\",\x20\"Contains\",\x20or\x20\
    \"StartsWith\"\n\n\x0c\n\x05\x04\t\x02\x02\x06\x12\x03[\x02\x0b\n\x0c\n\
    \x05\x04\t\x02\x02\x01\x12\x03[\x0c\x16\n\x0c\n\x05\x04\t\x02\x02\x03\
    \x12\x03[\x19\x1a\n\x0b\n\x04\x04\t\x02\x03\x12\x03\\\x02\x1e\n\x0c\n\
    \x05\x04\t\x02\x03\x05\x12\x03\\\x02\x06\n\x0c\n\x05\x04\t\x02\x03\x01\
    \x12\x03\\\x07\x19\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03\\\x1c\x1d\n\x0b\
    \n\x04\x04\t\x02\x04\x12\x03^\x02$\n\x0c\n\x05\x04\t\x02\x04\x04\x12\x03\
    ^\x02\n\n\x0c\n\x05\x04\t\x02\x04\x06\x12\x03^\x0b\x14\n\x0c\n\x05\x04\t\
    \x02\x04\x01\x12\x03^\x15\x1f\n\x0c\n\x05\x04\t\x02\x04\x03\x12\x03^\"#\
    \n\x0b\n\x04\x04\t\x02\x05\x12\x03_\x02&\n\x0c\n\x05\x04\t\x02\x05\x04\
    \x12\x03_\x02\n\n\x0c\n\x05\x04\t\x02\x05\x06\x12\x03_\x0b\x15\n\x0c\n\
    \x05\x04\t\x02\x05\x01\x12\x03_\x16!\n\x0c\n\x05\x04\t\x02\x05\x03\x12\
    \x03_$%\n#\n\x04\x04\t\x02\x06\x12\x03a\x02*\"\x16\x20{domain}_{id}\x20f\
    ormat\n\n\x0c\n\x05\x04\t\x02\x06\x04\x12\x03a\x02\n\n\x0c\n\x05\x04\t\
    \x02\x06\x05\x12\x03a\x0b\x11\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03a\x12\
    %\n\x0c\n\x05\x04\t\x02\x06\x03\x12\x03a()\n>\n\x04\x04\t\x02\x07\x12\
    \x03b\x02\"\"1\x20None,\x20Standard,\x20IgnoreQueryString\x20or\x20Aggre\
    ssive\n\n\x0c\n\x05\x04\t\x02\x07\x04\x12\x03b\x02\n\n\x0c\n\x05\x04\t\
    \x02\x07\x05\x12\x03b\x0b\x11\n\x0c\n\x05\x04\t\x02\x07\x01\x12\x03b\x12\
    \x1d\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03b\x20!\n\x0b\n\x04\x04\t\x02\
    \x08\x12\x03c\x02&\n\x0c\n\x05\x04\t\x02\x08\x04\x12\x03c\x02\n\n\x0c\n\
    \x05\x04\t\x02\x08\x05\x12\x03c\x0b\x11\n\x0c\n\x05\x04\t\x02\x08\x01\
    \x12\x03c\x12!\n\x0c\n\x05\x04\t\x02\x08\x03\x12\x03c$%\n\n\n\x02\x05\0\
    \x12\x04f\0k\x01\n\n\n\x03\x05\0\x01\x12\x03f\x05\x0e\n\x0b\n\x04\x05\0\
    \x02\0\x12\x03g\x02\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03g\x02\x05\n\x0c\
    \n\x05\x05\0\x02\0\x02\x12\x03g\x08\t\n\x0b\n\x04\x05\0\x02\x01\x12\x03h\
    \x02\x0b\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03h\x02\x06\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03h\t\n\n\x0b\n\x04\x05\0\x02\x02\x12\x03i\x02\r\n\
    \x0c\n\x05\x05\0\x02\x02\x01\x12\x03i\x02\x08\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03i\x0b\x0c\n\x0b\n\x04\x05\0\x02\x03\x12\x03j\x02\x0c\n\x0c\n\
    \x05\x05\0\x02\x03\x01\x12\x03j\x02\x07\n\x0c\n\x05\x05\0\x02\x03\x02\
    \x12\x03j\n\x0b\n\n\n\x02\x05\x01\x12\x04m\0r\x01\n\n\n\x03\x05\x01\x01\
    \x12\x03m\x05\x0f\n\x0b\n\x04\x05\x01\x02\0\x12\x03n\x02\n\n\x0c\n\x05\
    \x05\x01\x02\0\x01\x12\x03n\x02\x05\n\x0c\n\x05\x05\x01\x02\0\x02\x12\
    \x03n\x08\t\n\x0b\n\x04\x05\x01\x02\x01\x12\x03o\x02\x0b\n\x0c\n\x05\x05\
    \x01\x02\x01\x01\x12\x03o\x02\x06\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\
    \x03o\t\n\n\x0b\n\x04\x05\x01\x02\x02\x12\x03p\x02\x0e\n\x0c\n\x05\x05\
    \x01\x02\x02\x01\x12\x03p\x02\t\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03p\
    \x0c\r\n\x0b\n\x04\x05\x01\x02\x03\x12\x03q\x02\r\n\x0c\n\x05\x05\x01\
    \x02\x03\x01\x12\x03q\x02\x08\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03q\
    \x0b\x0c\n\x1e\n\x02\x04\n\x12\x04v\0z\x01\x1a\x12\x20CACHING\x20SETTING\
    S\n\n\n\n\x03\x04\n\x01\x12\x03v\x08\x17\n\x0b\n\x04\x04\n\x02\0\x12\x03\
    w\x02\x13\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03w\x02\x06\n\x0c\n\x05\x04\n\
    \x02\0\x01\x12\x03w\x07\x0e\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03w\x11\x12\
    \n\x0b\n\x04\x04\n\x02\x01\x12\x03x\x02\x1d\n\x0c\n\x05\x04\n\x02\x01\
    \x06\x12\x03x\x02\x0c\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03x\r\x18\n\x0c\
    \n\x05\x04\n\x02\x01\x03\x12\x03x\x1b\x1c\n\x0b\n\x04\x04\n\x02\x02\x12\
    \x03y\x02\"\n\x0c\n\x05\x04\n\x02\x02\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\
    \n\x02\x02\x05\x12\x03y\x0b\x11\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03y\
    \x12\x1d\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03y\x20!\n\x0b\n\x02\x05\x02\
    \x12\x05|\0\x81\x01\x01\n\n\n\x03\x05\x02\x01\x12\x03|\x05\x0f\n\x0b\n\
    \x04\x05\x02\x02\0\x12\x03}\x02\x0b\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03}\x02\x06\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03}\t\n\n\x0b\n\x04\x05\
    \x02\x02\x01\x12\x03~\x02\x0f\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03~\
    \x02\n\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03~\r\x0e\n\x0b\n\x04\x05\
    \x02\x02\x02\x12\x03\x7f\x02\x18\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03\
    \x7f\x02\x13\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\x7f\x16\x17\n\x0c\n\
    \x04\x05\x02\x02\x03\x12\x04\x80\x01\x02\x11\n\r\n\x05\x05\x02\x02\x03\
    \x01\x12\x04\x80\x01\x02\x0c\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\x80\
    \x01\x0f\x10\n\x1c\n\x02\x04\x0b\x12\x06\x85\x01\0\x88\x01\x01\x1a\x0e\
    \x20BOT\x20SETTINGS\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x85\x01\x08\x13\n,\
    \n\x04\x04\x0b\x02\0\x12\x04\x86\x01\x02\x13\"\x1e\x20if\x20the\x20manag\
    ement\x20is\x20enabled\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x86\x01\x02\
    \x06\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x86\x01\x07\x0e\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\x86\x01\x11\x12\n\x20\n\x04\x04\x0b\x02\x01\x12\
    \x04\x87\x01\x02\x18\"\x12\x20the\x20allowed\x20bots\n\n\r\n\x05\x04\x0b\
    \x02\x01\x04\x12\x04\x87\x01\x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\
    \x87\x01\x0b\x0e\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x87\x01\x0f\x13\n\
    \r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x87\x01\x16\x17\n\x0c\n\x02\x05\x03\
    \x12\x06\x8a\x01\0\x8e\x01\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\x8a\x01\
    \x05\x08\n\x0c\n\x04\x05\x03\x02\0\x12\x04\x8b\x01\x02\x10\n\r\n\x05\x05\
    \x03\x02\0\x01\x12\x04\x8b\x01\x02\x0b\n\r\n\x05\x05\x03\x02\0\x02\x12\
    \x04\x8b\x01\x0e\x0f\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\x8c\x01\x02\x0e\
    \n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\x8c\x01\x02\t\n\r\n\x05\x05\x03\
    \x02\x01\x02\x12\x04\x8c\x01\x0c\r\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\
    \x8d\x01\x02\x12\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\x8d\x01\x02\r\n\r\
    \n\x05\x05\x03\x02\x02\x02\x12\x04\x8d\x01\x10\x11\n,\n\x02\x04\x0c\x12\
    \x06\x92\x01\0\x94\x01\x01\x1a\x1e\x20RATELIMITING\x20BUCKET\x20SETTINGS\
    \n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x92\x01\x08\x16\n\x0c\n\x04\x04\x0c\
    \x02\0\x12\x04\x93\x01\x02\x1e\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\x93\
    \x01\x02\n\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x93\x01\x0b\x11\n\r\n\x05\
    \x04\x0c\x02\0\x01\x12\x04\x93\x01\x12\x19\n\r\n\x05\x04\x0c\x02\0\x03\
    \x12\x04\x93\x01\x1c\x1d\n\x0c\n\x02\x04\r\x12\x06\x96\x01\0\x99\x01\x01\
    \n\x0b\n\x03\x04\r\x01\x12\x04\x96\x01\x08\x0e\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\x97\x01\x02\x17\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x97\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x97\x01\t\x12\n\r\n\x05\x04\r\x02\
    \0\x03\x12\x04\x97\x01\x15\x16\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x98\x01\
    \x02\x15\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x98\x01\x02\x08\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\x98\x01\t\x10\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\x98\x01\x13\x14\n\x1a\n\x02\x04\x0e\x12\x06\x9d\x01\0\xa0\x01\x01\
    \x1a\x0c\x20PAGE\x20RULES\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x9d\x01\x08\
    \x11\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9e\x01\x02\x13\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\x9e\x01\x02\x06\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \x9e\x01\x07\x0e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9e\x01\x11\x12\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\x9f\x01\x02\x1e\n\r\n\x05\x04\x0e\x02\
    \x01\x04\x12\x04\x9f\x01\x02\n\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\x9f\
    \x01\x0b\x13\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x9f\x01\x14\x19\n\r\n\
    \x05\x04\x0e\x02\x01\x03\x12\x04\x9f\x01\x1c\x1d\n\x0c\n\x02\x04\x0f\x12\
    \x06\xa2\x01\0\xb8\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa2\x01\x08\
    \x10\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xa3\x01\x02\x10\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\xa3\x01\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \xa3\x01\t\x0b\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa3\x01\x0e\x0f\n\x0c\
    \n\x04\x04\x0f\x02\x01\x12\x04\xa4\x01\x02\x13\n\r\n\x05\x04\x0f\x02\x01\
    \x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xa4\
    \x01\t\x0e\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa4\x01\x11\x12\n,\n\
    \x04\x04\x0f\x02\x02\x12\x04\xa5\x01\x02\x1d\"\x1e\x20things\x20it\x20ca\
    n\x20be\x20matched\x20on!\n\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xa5\
    \x01\x02\n\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xa5\x01\x0b\x10\n\r\n\
    \x05\x04\x0f\x02\x02\x01\x12\x04\xa5\x01\x11\x18\n\r\n\x05\x04\x0f\x02\
    \x02\x03\x12\x04\xa5\x01\x1b\x1c\n!\n\x04\x04\x0f\x02\x03\x12\x04\xa7\
    \x01\x02!\"\x13\x20either\x20one\x20or\x20all\n\n\r\n\x05\x04\x0f\x02\
    \x03\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\
    \xa7\x01\t\x1c\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xa7\x01\x1f\x20\n\
    \x0c\n\x04\x04\x0f\x02\x04\x12\x04\xa9\x01\x02\x14\n\r\n\x05\x04\x0f\x02\
    \x04\x06\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\
    \xa9\x01\t\x0f\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xa9\x01\x12\x13\n)\
    \n\x04\x04\x0f\x02\x05\x12\x04\xab\x01\x02%\x1a\x1b\x20if\x20action\x20i\
    s\x20monopoly\x20...\n\n\r\n\x05\x04\x0f\x02\x05\x06\x12\x04\xab\x01\x02\
    \x10\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xab\x01\x11\x20\n\r\n\x05\x04\
    \x0f\x02\x05\x03\x12\x04\xab\x01#$\n,\n\x04\x04\x0f\x02\x06\x12\x04\xad\
    \x01\x020\x1a\x1e\x20if\x20action\x20is\x20a\x20trustbust\x20...\n\n\r\n\
    \x05\x04\x0f\x02\x06\x04\x12\x04\xad\x01\x02\n\n\r\n\x05\x04\x0f\x02\x06\
    \x06\x12\x04\xad\x01\x0b\x1a\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\xad\
    \x01\x1b+\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\xad\x01./\n*\n\x04\x04\
    \x0f\x02\x07\x12\x04\xb0\x01\x02\"\x1a\x1c\x20special\x20action\x20infor\
    mation\n\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\xb0\x01\x02\n\n\r\n\x05\
    \x04\x0f\x02\x07\x05\x12\x04\xb0\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x07\
    \x01\x12\x04\xb0\x01\x12\x1d\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xb0\
    \x01\x20!\n\x17\n\x04\x04\x0f\x02\x08\x12\x04\xb2\x01\x02&\x1a\t\x20cach\
    ing\n\n\r\n\x05\x04\x0f\x02\x08\x04\x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\
    \x0f\x02\x08\x06\x12\x04\xb2\x01\x0b\x15\n\r\n\x05\x04\x0f\x02\x08\x01\
    \x12\x04\xb2\x01\x16!\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\xb2\x01$%\n\
    \x0c\n\x04\x04\x0f\x02\t\x12\x04\xb3\x01\x02!\n\r\n\x05\x04\x0f\x02\t\
    \x04\x12\x04\xb3\x01\x02\n\n\r\n\x05\x04\x0f\x02\t\x05\x12\x04\xb3\x01\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\xb3\x01\x12\x1b\n\r\n\x05\
    \x04\x0f\x02\t\x03\x12\x04\xb3\x01\x1e\x20\n\x1b\n\x04\x04\x0f\x02\n\x12\
    \x04\xb5\x01\x02\x20\x1a\r\x20redirect\x20to\n\n\r\n\x05\x04\x0f\x02\n\
    \x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x0f\x02\n\x05\x12\x04\xb5\x01\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\n\x01\x12\x04\xb5\x01\x12\x1a\n\r\n\x05\
    \x04\x0f\x02\n\x03\x12\x04\xb5\x01\x1d\x1f\n,\n\x04\x04\x0f\x02\x0b\x12\
    \x04\xb7\x01\x02$\x1a\x1e\x20use\x20backend,\x20fetch\x20from\x20host\n\
    \n\r\n\x05\x04\x0f\x02\x0b\x04\x12\x04\xb7\x01\x02\n\n\r\n\x05\x04\x0f\
    \x02\x0b\x05\x12\x04\xb7\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x0b\x01\x12\
    \x04\xb7\x01\x12\x1e\n\r\n\x05\x04\x0f\x02\x0b\x03\x12\x04\xb7\x01!#\n\
    \x0c\n\x02\x04\x10\x12\x06\xba\x01\0\xc4\x01\x01\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\xba\x01\x08\r\n3\n\x04\x04\x10\x02\0\x12\x04\xbb\x01\x02\x1f\"%\
    \x20ip,\x20path,\x20bunch\x20of\x20other\x20cool\x20stuff\n\n\r\n\x05\
    \x04\x10\x02\0\x06\x12\x04\xbb\x01\x02\r\n\r\n\x05\x04\x10\x02\0\x01\x12\
    \x04\xbb\x01\x0e\x1a\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xbb\x01\x1d\x1e\
    \n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xbc\x01\x02\x1b\n\r\n\x05\x04\x10\
    \x02\x01\x06\x12\x04\xbc\x01\x02\x0b\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\xbc\x01\x0c\x16\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xbc\x01\x19\
    \x1a\nM\n\x04\x04\x10\x02\x02\x12\x04\xbe\x01\x02\"\"?\x20the\x20string\
    \x20we\x20are\x20going\x20to\x20compare\x20the\x20fetched\x20information\
    \x20to\n\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xbe\x01\x02\n\n\r\n\x05\
    \x04\x10\x02\x02\x05\x12\x04\xbe\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\xbe\x01\x12\x1d\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xbe\
    \x01\x20!\nZ\n\x04\x04\x10\x02\x03\x12\x04\xbf\x01\x02$\"L\x20or\x20opti\
    onally,\x20key\x20value\x20data.\x20empty\x20map\x20if\x20it\x20doesn't\
    \x20use\x20key\x20value\x20data.\n\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\
    \xbf\x01\x02\x15\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xbf\x01\x16\x1f\n\
    \r\n\x05\x04\x10\x02\x03\x03\x12\x04\xbf\x01\"#\n\x1f\n\x04\x04\x10\x02\
    \x04\x12\x04\xc2\x01\x02\x14\x1a\x11\x20special\x20options\n\n\r\n\x05\
    \x04\x10\x02\x04\x05\x12\x04\xc2\x01\x02\x06\n\r\n\x05\x04\x10\x02\x04\
    \x01\x12\x04\xc2\x01\x07\x0f\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xc2\
    \x01\x12\x13\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xc3\x01\x02\x14\n\r\n\
    \x05\x04\x10\x02\x05\x05\x12\x04\xc3\x01\x02\x06\n\r\n\x05\x04\x10\x02\
    \x05\x01\x12\x04\xc3\x01\x07\x0f\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\
    \xc3\x01\x12\x13\n\x0c\n\x02\x05\x04\x12\x06\xc6\x01\0\xce\x01\x01\n\x0b\
    \n\x03\x05\x04\x01\x12\x04\xc6\x01\x05\x10\n\x0c\n\x04\x05\x04\x02\0\x12\
    \x04\xc7\x01\x02\t\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xc7\x01\x02\x04\n\
    \r\n\x05\x05\x04\x02\0\x02\x12\x04\xc7\x01\x07\x08\n\x0c\n\x04\x05\x04\
    \x02\x01\x12\x04\xc8\x01\x02\x0b\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\
    \xc8\x01\x02\x06\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xc8\x01\t\n\n\x0c\
    \n\x04\x05\x04\x02\x02\x12\x04\xc9\x01\x02\x0c\n\r\n\x05\x05\x04\x02\x02\
    \x01\x12\x04\xc9\x01\x02\x07\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xc9\
    \x01\n\x0b\n\x0c\n\x04\x05\x04\x02\x03\x12\x04\xca\x01\x02\n\n\r\n\x05\
    \x05\x04\x02\x03\x01\x12\x04\xca\x01\x02\x05\n\r\n\x05\x05\x04\x02\x03\
    \x02\x12\x04\xca\x01\x08\t\n\x0c\n\x04\x05\x04\x02\x04\x12\x04\xcb\x01\
    \x02\x0e\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xcb\x01\x02\t\n\r\n\x05\
    \x05\x04\x02\x04\x02\x12\x04\xcb\x01\x0c\r\n\x0c\n\x04\x05\x04\x02\x05\
    \x12\x04\xcc\x01\x02\x10\n\r\n\x05\x05\x04\x02\x05\x01\x12\x04\xcc\x01\
    \x02\x0b\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xcc\x01\x0e\x0f\n\x0c\n\
    \x04\x05\x04\x02\x06\x12\x04\xcd\x01\x02\x0e\n\r\n\x05\x05\x04\x02\x06\
    \x01\x12\x04\xcd\x01\x02\t\n\r\n\x05\x05\x04\x02\x06\x02\x12\x04\xcd\x01\
    \x0c\r\n4\n\x02\x05\x05\x12\x06\xd1\x01\0\xd5\x01\x01\x1a&\x20can\x20be\
    \x20shared\x20for\x20API\x20engine\x20as\x20well\n\n\x0b\n\x03\x05\x05\
    \x01\x12\x04\xd1\x01\x05\x0e\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xd2\x01\
    \x02\x0c\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xd2\x01\x02\x07\n\r\n\x05\
    \x05\x05\x02\0\x02\x12\x04\xd2\x01\n\x0b\n\x0c\n\x04\x05\x05\x02\x01\x12\
    \x04\xd3\x01\x02\x0f\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xd3\x01\x02\n\
    \n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xd3\x01\r\x0e\n\x0c\n\x04\x05\x05\
    \x02\x02\x12\x04\xd4\x01\x02\x11\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\
    \xd4\x01\x02\x0c\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xd4\x01\x0f\x10\n\
    \x0c\n\x02\x05\x06\x12\x06\xd7\x01\0\xda\x01\x01\n\x0b\n\x03\x05\x06\x01\
    \x12\x04\xd7\x01\x05\x0b\n\x0c\n\x04\x05\x06\x02\0\x12\x04\xd8\x01\x02\
    \x0f\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xd8\x01\x02\n\n\r\n\x05\x05\x06\
    \x02\0\x02\x12\x04\xd8\x01\r\x0e\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\xd9\
    \x01\x02\x13\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xd9\x01\x02\x0e\n\r\n\
    \x05\x05\x06\x02\x01\x02\x12\x04\xd9\x01\x11\x12\n\x0c\n\x02\x05\x07\x12\
    \x06\xdc\x01\0\xde\x01\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\xdc\x01\x05\
    \x13\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xdd\x01\x02\x0c\n\r\n\x05\x05\x07\
    \x02\0\x01\x12\x04\xdd\x01\x02\x07\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\
    \xdd\x01\n\x0b\n\x0c\n\x02\x05\x08\x12\x06\xe0\x01\0\xe7\x01\x01\n\x0b\n\
    \x03\x05\x08\x01\x12\x04\xe0\x01\x05\x14\n\x0c\n\x04\x05\x08\x02\0\x12\
    \x04\xe1\x01\x02\x15\n\r\n\x05\x05\x08\x02\0\x01\x12\x04\xe1\x01\x02\x10\
    \n\r\n\x05\x05\x08\x02\0\x02\x12\x04\xe1\x01\x13\x14\n\x0c\n\x04\x05\x08\
    \x02\x01\x12\x04\xe2\x01\x02\x17\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\
    \xe2\x01\x02\x12\n\r\n\x05\x05\x08\x02\x01\x02\x12\x04\xe2\x01\x15\x16\n\
    \x0c\n\x04\x05\x08\x02\x02\x12\x04\xe3\x01\x02\x16\n\r\n\x05\x05\x08\x02\
    \x02\x01\x12\x04\xe3\x01\x02\x11\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\
    \xe3\x01\x14\x15\n\x0c\n\x04\x05\x08\x02\x03\x12\x04\xe4\x01\x02\x0c\n\r\
    \n\x05\x05\x08\x02\x03\x01\x12\x04\xe4\x01\x02\x07\n\r\n\x05\x05\x08\x02\
    \x03\x02\x12\x04\xe4\x01\n\x0b\n\x0c\n\x04\x05\x08\x02\x04\x12\x04\xe5\
    \x01\x02\x0f\n\r\n\x05\x05\x08\x02\x04\x01\x12\x04\xe5\x01\x02\n\n\r\n\
    \x05\x05\x08\x02\x04\x02\x12\x04\xe5\x01\r\x0e\n\x0c\n\x04\x05\x08\x02\
    \x05\x12\x04\xe6\x01\x02\x11\n\r\n\x05\x05\x08\x02\x05\x01\x12\x04\xe6\
    \x01\x02\x0c\n\r\n\x05\x05\x08\x02\x05\x02\x12\x04\xe6\x01\x0f\x10\n!\n\
    \x02\x04\x11\x12\x06\xeb\x01\0\xf8\x01\x01\x1a\x13\x20INTERNAL\x20SETTIN\
    GS\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xeb\x01\x08\x18\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\xec\x01\x02\x15\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xec\
    \x01\x02\x06\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xec\x01\x07\x10\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xec\x01\x13\x14\n\x0c\n\x04\x04\x11\x02\
    \x01\x12\x04\xed\x01\x02\x1a\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xed\
    \x01\x02\x06\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xed\x01\x07\x15\n\r\n\
    \x05\x04\x11\x02\x01\x03\x12\x04\xed\x01\x18\x19\n\x20\n\x04\x04\x11\x02\
    \x02\x12\x04\xee\x01\x02\x1d\"\x12\x20uploads\x20and\x20such\n\n\r\n\x05\
    \x04\x11\x02\x02\x05\x12\x04\xee\x01\x02\x08\n\r\n\x05\x04\x11\x02\x02\
    \x01\x12\x04\xee\x01\t\x18\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xee\x01\
    \x1b\x1c\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xef\x01\x02$\n\r\n\x05\x04\
    \x11\x02\x03\x05\x12\x04\xef\x01\x02\x08\n\r\n\x05\x04\x11\x02\x03\x01\
    \x12\x04\xef\x01\t\x1f\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xef\x01\"#\
    \n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xf0\x01\x02\x1d\n\r\n\x05\x04\x11\
    \x02\x04\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04\x11\x02\x04\x01\x12\
    \x04\xf0\x01\t\x18\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xf0\x01\x1b\x1c\
    \n\x1c\n\x04\x04\x11\x02\x05\x12\x04\xf2\x01\x02\x1c\x1a\x0e\x20bytes\
    \x20/\x201000\n\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\xf2\x01\x02\x08\n\
    \r\n\x05\x04\x11\x02\x05\x01\x12\x04\xf2\x01\t\x17\n\r\n\x05\x04\x11\x02\
    \x05\x03\x12\x04\xf2\x01\x1a\x1b\n\x0c\n\x04\x04\x11\x02\x06\x12\x04\xf3\
    \x01\x02\x1f\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xf3\x01\x02\x08\n\r\n\
    \x05\x04\x11\x02\x06\x01\x12\x04\xf3\x01\t\x1a\n\r\n\x05\x04\x11\x02\x06\
    \x03\x12\x04\xf3\x01\x1d\x1e\n\x0c\n\x04\x04\x11\x02\x07\x12\x04\xf5\x01\
    \x02\x20\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xf5\x01\x02\x08\n\r\n\x05\
    \x04\x11\x02\x07\x01\x12\x04\xf5\x01\t\x1b\n\r\n\x05\x04\x11\x02\x07\x03\
    \x12\x04\xf5\x01\x1e\x1f\n\x1e\n\x04\x04\x11\x02\x08\x12\x04\xf6\x01\x02\
    (\"\x10\x20ratelimit\x20serv\n\n\r\n\x05\x04\x11\x02\x08\x05\x12\x04\xf6\
    \x01\x02\x08\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\xf6\x01\t\"\n\r\n\x05\
    \x04\x11\x02\x08\x03\x12\x04\xf6\x01%'\nI\n\x04\x04\x11\x02\t\x12\x04\
    \xf7\x01\x02\"\";\x20the\x20amount\x20of\x20allowed\x20websocket\x20conn\
    ections\x20in\x2010\x20seconds\n\n\r\n\x05\x04\x11\x02\t\x05\x12\x04\xf7\
    \x01\x02\x08\n\r\n\x05\x04\x11\x02\t\x01\x12\x04\xf7\x01\t\x1c\n\r\n\x05\
    \x04\x11\x02\t\x03\x12\x04\xf7\x01\x1f!b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(18);
            messages.push(QueryResponse::generated_message_descriptor_data());
            messages.push(AllDomainSchema::generated_message_descriptor_data());
            messages.push(PartialDomainSchema::generated_message_descriptor_data());
            messages.push(FullDomainSchema::generated_message_descriptor_data());
            messages.push(DeleteDomainSchema::generated_message_descriptor_data());
            messages.push(OriginSetting::generated_message_descriptor_data());
            messages.push(Origin::generated_message_descriptor_data());
            messages.push(ApiEngineSettings::generated_message_descriptor_data());
            messages.push(ApiEngineSetting::generated_message_descriptor_data());
            messages.push(ApiEngineRule::generated_message_descriptor_data());
            messages.push(CachingSettings::generated_message_descriptor_data());
            messages.push(BotSettings::generated_message_descriptor_data());
            messages.push(BucketSettings::generated_message_descriptor_data());
            messages.push(Bucket::generated_message_descriptor_data());
            messages.push(PageRules::generated_message_descriptor_data());
            messages.push(PageRule::generated_message_descriptor_data());
            messages.push(Match::generated_message_descriptor_data());
            messages.push(InternalSettings::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(WsMethods::generated_enum_descriptor_data());
            enums.push(WebMethods::generated_enum_descriptor_data());
            enums.push(CacheLevel::generated_enum_descriptor_data());
            enums.push(Bot::generated_enum_descriptor_data());
            enums.push(TriggerType::generated_enum_descriptor_data());
            enums.push(MatchType::generated_enum_descriptor_data());
            enums.push(Action::generated_enum_descriptor_data());
            enums.push(MonopolyAction::generated_enum_descriptor_data());
            enums.push(TrustBustOption::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
