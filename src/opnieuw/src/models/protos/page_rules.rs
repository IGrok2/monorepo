// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `page_rules.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:QueryResponse)
pub struct QueryResponse {
    // message fields
    // @@protoc_insertion_point(field:QueryResponse.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:QueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryResponse {
    fn default() -> &'a QueryResponse {
        <QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &QueryResponse| { &m.success },
            |m: &mut QueryResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryResponse>(
            "QueryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryResponse {
    const NAME: &'static str = "QueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryResponse {
        static instance: QueryResponse = QueryResponse {
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:EnableStatusUpdate)
pub struct EnableStatusUpdate {
    // message fields
    // @@protoc_insertion_point(field:EnableStatusUpdate.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:EnableStatusUpdate.enabled)
    pub enabled: bool,
    // special fields
    // @@protoc_insertion_point(special_field:EnableStatusUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnableStatusUpdate {
    fn default() -> &'a EnableStatusUpdate {
        <EnableStatusUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EnableStatusUpdate {
    pub fn new() -> EnableStatusUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &EnableStatusUpdate| { &m.domain },
            |m: &mut EnableStatusUpdate| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &EnableStatusUpdate| { &m.enabled },
            |m: &mut EnableStatusUpdate| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnableStatusUpdate>(
            "EnableStatusUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnableStatusUpdate {
    const NAME: &'static str = "EnableStatusUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                16 => {
                    self.enabled = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if self.enabled != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnableStatusUpdate {
        EnableStatusUpdate::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.enabled = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnableStatusUpdate {
        static instance: EnableStatusUpdate = EnableStatusUpdate {
            domain: ::std::string::String::new(),
            enabled: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnableStatusUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnableStatusUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnableStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableStatusUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ! NEW PAGE RULE !
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NewPageRule)
pub struct NewPageRule {
    // message fields
    ///  required information
    // @@protoc_insertion_point(field:NewPageRule.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:NewPageRule.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:NewPageRule.order)
    pub order: ::std::option::Option<i32>,
    ///  trigger
    // @@protoc_insertion_point(field:NewPageRule.match_type)
    pub match_type: ::std::vec::Vec<MatchNew>,
    // @@protoc_insertion_point(field:NewPageRule.trigger_requirement)
    pub trigger_requirement: ::protobuf::EnumOrUnknown<TriggerRequirement>,
    // @@protoc_insertion_point(field:NewPageRule.inversed)
    pub inversed: bool,
    ///  action
    // @@protoc_insertion_point(field:NewPageRule.action)
    pub action: ::protobuf::EnumOrUnknown<Action>,
    // @@protoc_insertion_point(field:NewPageRule.monopoly)
    pub monopoly: ::std::option::Option<::protobuf::EnumOrUnknown<MonopolyAction>>,
    // @@protoc_insertion_point(field:NewPageRule.trustbust)
    pub trustbust: ::std::vec::Vec<::protobuf::EnumOrUnknown<TrustBustOption>>,
    ///  optional action options
    // @@protoc_insertion_point(field:NewPageRule.bucket_name)
    pub bucket_name: ::std::option::Option<::std::string::String>,
    ///  caching
    // @@protoc_insertion_point(field:NewPageRule.cache_level)
    pub cache_level: ::std::option::Option<::protobuf::EnumOrUnknown<CacheLevel>>,
    // @@protoc_insertion_point(field:NewPageRule.default_cache_ttl)
    pub default_cache_ttl: ::std::option::Option<i32>,
    ///  redirect to
    // @@protoc_insertion_point(field:NewPageRule.redirect)
    pub redirect: ::std::option::Option<::std::string::String>,
    ///  use backend, fetch its id
    // @@protoc_insertion_point(field:NewPageRule.backend_id)
    pub backend_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NewPageRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NewPageRule {
    fn default() -> &'a NewPageRule {
        <NewPageRule as ::protobuf::Message>::default_instance()
    }
}

impl NewPageRule {
    pub fn new() -> NewPageRule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &NewPageRule| { &m.domain },
            |m: &mut NewPageRule| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &NewPageRule| { &m.id },
            |m: &mut NewPageRule| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order",
            |m: &NewPageRule| { &m.order },
            |m: &mut NewPageRule| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "match_type",
            |m: &NewPageRule| { &m.match_type },
            |m: &mut NewPageRule| { &mut m.match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trigger_requirement",
            |m: &NewPageRule| { &m.trigger_requirement },
            |m: &mut NewPageRule| { &mut m.trigger_requirement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inversed",
            |m: &NewPageRule| { &m.inversed },
            |m: &mut NewPageRule| { &mut m.inversed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &NewPageRule| { &m.action },
            |m: &mut NewPageRule| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "monopoly",
            |m: &NewPageRule| { &m.monopoly },
            |m: &mut NewPageRule| { &mut m.monopoly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trustbust",
            |m: &NewPageRule| { &m.trustbust },
            |m: &mut NewPageRule| { &mut m.trustbust },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bucket_name",
            |m: &NewPageRule| { &m.bucket_name },
            |m: &mut NewPageRule| { &mut m.bucket_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_level",
            |m: &NewPageRule| { &m.cache_level },
            |m: &mut NewPageRule| { &mut m.cache_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_cache_ttl",
            |m: &NewPageRule| { &m.default_cache_ttl },
            |m: &mut NewPageRule| { &mut m.default_cache_ttl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redirect",
            |m: &NewPageRule| { &m.redirect },
            |m: &mut NewPageRule| { &mut m.redirect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backend_id",
            |m: &NewPageRule| { &m.backend_id },
            |m: &mut NewPageRule| { &mut m.backend_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NewPageRule>(
            "NewPageRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NewPageRule {
    const NAME: &'static str = "NewPageRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                24 => {
                    self.order = ::std::option::Option::Some(is.read_sint32()?);
                },
                34 => {
                    self.match_type.push(is.read_message()?);
                },
                40 => {
                    self.trigger_requirement = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.inversed = is.read_bool()?;
                },
                56 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.monopoly = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.trustbust.push(is.read_enum_or_unknown()?);
                },
                74 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.trustbust)?
                },
                82 => {
                    self.bucket_name = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.cache_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.default_cache_ttl = ::std::option::Option::Some(is.read_sint32()?);
                },
                106 => {
                    self.redirect = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.backend_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.order {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        for value in &self.match_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.trigger_requirement != ::protobuf::EnumOrUnknown::new(TriggerRequirement::One) {
            my_size += ::protobuf::rt::int32_size(5, self.trigger_requirement.value());
        }
        if self.inversed != false {
            my_size += 1 + 1;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(Action::Monopoly) {
            my_size += ::protobuf::rt::int32_size(7, self.action.value());
        }
        if let Some(v) = self.monopoly {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        for value in &self.trustbust {
            my_size += ::protobuf::rt::int32_size(9, value.value());
        };
        if let Some(v) = self.bucket_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.cache_level {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.default_cache_ttl {
            my_size += ::protobuf::rt::sint32_size(12, v);
        }
        if let Some(v) = self.redirect.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.backend_id.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.order {
            os.write_sint32(3, v)?;
        }
        for v in &self.match_type {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.trigger_requirement != ::protobuf::EnumOrUnknown::new(TriggerRequirement::One) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.trigger_requirement))?;
        }
        if self.inversed != false {
            os.write_bool(6, self.inversed)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(Action::Monopoly) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if let Some(v) = self.monopoly {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.trustbust {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.bucket_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.cache_level {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_cache_ttl {
            os.write_sint32(12, v)?;
        }
        if let Some(v) = self.redirect.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.backend_id.as_ref() {
            os.write_string(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NewPageRule {
        NewPageRule::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.id.clear();
        self.order = ::std::option::Option::None;
        self.match_type.clear();
        self.trigger_requirement = ::protobuf::EnumOrUnknown::new(TriggerRequirement::One);
        self.inversed = false;
        self.action = ::protobuf::EnumOrUnknown::new(Action::Monopoly);
        self.monopoly = ::std::option::Option::None;
        self.trustbust.clear();
        self.bucket_name = ::std::option::Option::None;
        self.cache_level = ::std::option::Option::None;
        self.default_cache_ttl = ::std::option::Option::None;
        self.redirect = ::std::option::Option::None;
        self.backend_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NewPageRule {
        static instance: NewPageRule = NewPageRule {
            domain: ::std::string::String::new(),
            id: ::std::string::String::new(),
            order: ::std::option::Option::None,
            match_type: ::std::vec::Vec::new(),
            trigger_requirement: ::protobuf::EnumOrUnknown::from_i32(0),
            inversed: false,
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            monopoly: ::std::option::Option::None,
            trustbust: ::std::vec::Vec::new(),
            bucket_name: ::std::option::Option::None,
            cache_level: ::std::option::Option::None,
            default_cache_ttl: ::std::option::Option::None,
            redirect: ::std::option::Option::None,
            backend_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NewPageRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NewPageRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NewPageRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewPageRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MatchNew)
pub struct MatchNew {
    // message fields
    // @@protoc_insertion_point(field:MatchNew.trigger)
    pub trigger: ::protobuf::EnumOrUnknown<TriggerType>,
    // @@protoc_insertion_point(field:MatchNew.pure_string)
    pub pure_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MatchNew.key_value)
    pub key_value: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MatchNew.m_type)
    pub m_type: ::protobuf::EnumOrUnknown<MatchType>,
    // @@protoc_insertion_point(field:MatchNew.inversed)
    pub inversed: bool,
    // @@protoc_insertion_point(field:MatchNew.required)
    pub required: bool,
    // special fields
    // @@protoc_insertion_point(special_field:MatchNew.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchNew {
    fn default() -> &'a MatchNew {
        <MatchNew as ::protobuf::Message>::default_instance()
    }
}

impl MatchNew {
    pub fn new() -> MatchNew {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trigger",
            |m: &MatchNew| { &m.trigger },
            |m: &mut MatchNew| { &mut m.trigger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pure_string",
            |m: &MatchNew| { &m.pure_string },
            |m: &mut MatchNew| { &mut m.pure_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "key_value",
            |m: &MatchNew| { &m.key_value },
            |m: &mut MatchNew| { &mut m.key_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "m_type",
            |m: &MatchNew| { &m.m_type },
            |m: &mut MatchNew| { &mut m.m_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inversed",
            |m: &MatchNew| { &m.inversed },
            |m: &mut MatchNew| { &mut m.inversed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "required",
            |m: &MatchNew| { &m.required },
            |m: &mut MatchNew| { &mut m.required },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchNew>(
            "MatchNew",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchNew {
    const NAME: &'static str = "MatchNew";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trigger = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.pure_string = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.key_value.push(is.read_string()?);
                },
                32 => {
                    self.m_type = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.inversed = is.read_bool()?;
                },
                48 => {
                    self.required = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.trigger != ::protobuf::EnumOrUnknown::new(TriggerType::Ip) {
            my_size += ::protobuf::rt::int32_size(1, self.trigger.value());
        }
        if let Some(v) = self.pure_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.key_value {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.m_type != ::protobuf::EnumOrUnknown::new(MatchType::Exact) {
            my_size += ::protobuf::rt::int32_size(4, self.m_type.value());
        }
        if self.inversed != false {
            my_size += 1 + 1;
        }
        if self.required != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.trigger != ::protobuf::EnumOrUnknown::new(TriggerType::Ip) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.trigger))?;
        }
        if let Some(v) = self.pure_string.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.key_value {
            os.write_string(3, &v)?;
        };
        if self.m_type != ::protobuf::EnumOrUnknown::new(MatchType::Exact) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.m_type))?;
        }
        if self.inversed != false {
            os.write_bool(5, self.inversed)?;
        }
        if self.required != false {
            os.write_bool(6, self.required)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchNew {
        MatchNew::new()
    }

    fn clear(&mut self) {
        self.trigger = ::protobuf::EnumOrUnknown::new(TriggerType::Ip);
        self.pure_string = ::std::option::Option::None;
        self.key_value.clear();
        self.m_type = ::protobuf::EnumOrUnknown::new(MatchType::Exact);
        self.inversed = false;
        self.required = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchNew {
        static instance: MatchNew = MatchNew {
            trigger: ::protobuf::EnumOrUnknown::from_i32(0),
            pure_string: ::std::option::Option::None,
            key_value: ::std::vec::Vec::new(),
            m_type: ::protobuf::EnumOrUnknown::from_i32(0),
            inversed: false,
            required: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchNew {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchNew").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchNew {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchNew {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ! UPDATE PAGE RULE !
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UpdatePageRuleSchema)
pub struct UpdatePageRuleSchema {
    // message fields
    ///  required information
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.order)
    pub order: ::std::option::Option<i32>,
    ///  trigger
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.match_type)
    pub match_type: ::std::vec::Vec<MatchNew>,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.trigger_requirement)
    pub trigger_requirement: ::std::option::Option<::protobuf::EnumOrUnknown<TriggerRequirement>>,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.inversed)
    pub inversed: ::std::option::Option<bool>,
    ///  action
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.action)
    pub action: ::std::option::Option<::protobuf::EnumOrUnknown<Action>>,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.monopoly)
    pub monopoly: ::std::option::Option<::protobuf::EnumOrUnknown<MonopolyAction>>,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.trustbust)
    pub trustbust: ::std::vec::Vec<::protobuf::EnumOrUnknown<TrustBustOption>>,
    ///  optional action options
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.bucket_name)
    pub bucket_name: ::std::option::Option<::std::string::String>,
    ///  caching
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.cache_level)
    pub cache_level: ::std::option::Option<::protobuf::EnumOrUnknown<CacheLevel>>,
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.default_cache_ttl)
    pub default_cache_ttl: ::std::option::Option<i32>,
    ///  redirect to
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.redirect)
    pub redirect: ::std::option::Option<::std::string::String>,
    ///  use backend, fetch its id
    // @@protoc_insertion_point(field:UpdatePageRuleSchema.backend_id)
    pub backend_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:UpdatePageRuleSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdatePageRuleSchema {
    fn default() -> &'a UpdatePageRuleSchema {
        <UpdatePageRuleSchema as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePageRuleSchema {
    pub fn new() -> UpdatePageRuleSchema {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &UpdatePageRuleSchema| { &m.domain },
            |m: &mut UpdatePageRuleSchema| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UpdatePageRuleSchema| { &m.id },
            |m: &mut UpdatePageRuleSchema| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order",
            |m: &UpdatePageRuleSchema| { &m.order },
            |m: &mut UpdatePageRuleSchema| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "match_type",
            |m: &UpdatePageRuleSchema| { &m.match_type },
            |m: &mut UpdatePageRuleSchema| { &mut m.match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trigger_requirement",
            |m: &UpdatePageRuleSchema| { &m.trigger_requirement },
            |m: &mut UpdatePageRuleSchema| { &mut m.trigger_requirement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inversed",
            |m: &UpdatePageRuleSchema| { &m.inversed },
            |m: &mut UpdatePageRuleSchema| { &mut m.inversed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &UpdatePageRuleSchema| { &m.action },
            |m: &mut UpdatePageRuleSchema| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "monopoly",
            |m: &UpdatePageRuleSchema| { &m.monopoly },
            |m: &mut UpdatePageRuleSchema| { &mut m.monopoly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trustbust",
            |m: &UpdatePageRuleSchema| { &m.trustbust },
            |m: &mut UpdatePageRuleSchema| { &mut m.trustbust },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bucket_name",
            |m: &UpdatePageRuleSchema| { &m.bucket_name },
            |m: &mut UpdatePageRuleSchema| { &mut m.bucket_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_level",
            |m: &UpdatePageRuleSchema| { &m.cache_level },
            |m: &mut UpdatePageRuleSchema| { &mut m.cache_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_cache_ttl",
            |m: &UpdatePageRuleSchema| { &m.default_cache_ttl },
            |m: &mut UpdatePageRuleSchema| { &mut m.default_cache_ttl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redirect",
            |m: &UpdatePageRuleSchema| { &m.redirect },
            |m: &mut UpdatePageRuleSchema| { &mut m.redirect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backend_id",
            |m: &UpdatePageRuleSchema| { &m.backend_id },
            |m: &mut UpdatePageRuleSchema| { &mut m.backend_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdatePageRuleSchema>(
            "UpdatePageRuleSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdatePageRuleSchema {
    const NAME: &'static str = "UpdatePageRuleSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                24 => {
                    self.order = ::std::option::Option::Some(is.read_sint32()?);
                },
                34 => {
                    self.match_type.push(is.read_message()?);
                },
                40 => {
                    self.trigger_requirement = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.inversed = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.monopoly = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.trustbust.push(is.read_enum_or_unknown()?);
                },
                74 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.trustbust)?
                },
                82 => {
                    self.bucket_name = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.cache_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.default_cache_ttl = ::std::option::Option::Some(is.read_sint32()?);
                },
                106 => {
                    self.redirect = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.backend_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.order {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        for value in &self.match_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.trigger_requirement {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.inversed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.monopoly {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        for value in &self.trustbust {
            my_size += ::protobuf::rt::int32_size(9, value.value());
        };
        if let Some(v) = self.bucket_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.cache_level {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.default_cache_ttl {
            my_size += ::protobuf::rt::sint32_size(12, v);
        }
        if let Some(v) = self.redirect.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.backend_id.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.order {
            os.write_sint32(3, v)?;
        }
        for v in &self.match_type {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.trigger_requirement {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inversed {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.monopoly {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.trustbust {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.bucket_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.cache_level {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_cache_ttl {
            os.write_sint32(12, v)?;
        }
        if let Some(v) = self.redirect.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.backend_id.as_ref() {
            os.write_string(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdatePageRuleSchema {
        UpdatePageRuleSchema::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.id.clear();
        self.order = ::std::option::Option::None;
        self.match_type.clear();
        self.trigger_requirement = ::std::option::Option::None;
        self.inversed = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.monopoly = ::std::option::Option::None;
        self.trustbust.clear();
        self.bucket_name = ::std::option::Option::None;
        self.cache_level = ::std::option::Option::None;
        self.default_cache_ttl = ::std::option::Option::None;
        self.redirect = ::std::option::Option::None;
        self.backend_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdatePageRuleSchema {
        static instance: UpdatePageRuleSchema = UpdatePageRuleSchema {
            domain: ::std::string::String::new(),
            id: ::std::string::String::new(),
            order: ::std::option::Option::None,
            match_type: ::std::vec::Vec::new(),
            trigger_requirement: ::std::option::Option::None,
            inversed: ::std::option::Option::None,
            action: ::std::option::Option::None,
            monopoly: ::std::option::Option::None,
            trustbust: ::std::vec::Vec::new(),
            bucket_name: ::std::option::Option::None,
            cache_level: ::std::option::Option::None,
            default_cache_ttl: ::std::option::Option::None,
            redirect: ::std::option::Option::None,
            backend_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdatePageRuleSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdatePageRuleSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdatePageRuleSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePageRuleSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MatchUpdate)
pub struct MatchUpdate {
    // message fields
    // @@protoc_insertion_point(field:MatchUpdate.trigger)
    pub trigger: ::std::option::Option<::protobuf::EnumOrUnknown<TriggerType>>,
    // @@protoc_insertion_point(field:MatchUpdate.pure_string)
    pub pure_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MatchUpdate.key_value)
    pub key_value: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:MatchUpdate.m_type)
    pub m_type: ::std::option::Option<::protobuf::EnumOrUnknown<MatchType>>,
    // @@protoc_insertion_point(field:MatchUpdate.inversed)
    pub inversed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MatchUpdate.required)
    pub required: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MatchUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchUpdate {
    fn default() -> &'a MatchUpdate {
        <MatchUpdate as ::protobuf::Message>::default_instance()
    }
}

impl MatchUpdate {
    pub fn new() -> MatchUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trigger",
            |m: &MatchUpdate| { &m.trigger },
            |m: &mut MatchUpdate| { &mut m.trigger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pure_string",
            |m: &MatchUpdate| { &m.pure_string },
            |m: &mut MatchUpdate| { &mut m.pure_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "key_value",
            |m: &MatchUpdate| { &m.key_value },
            |m: &mut MatchUpdate| { &mut m.key_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m_type",
            |m: &MatchUpdate| { &m.m_type },
            |m: &mut MatchUpdate| { &mut m.m_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inversed",
            |m: &MatchUpdate| { &m.inversed },
            |m: &mut MatchUpdate| { &mut m.inversed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required",
            |m: &MatchUpdate| { &m.required },
            |m: &mut MatchUpdate| { &mut m.required },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchUpdate>(
            "MatchUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchUpdate {
    const NAME: &'static str = "MatchUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trigger = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.pure_string = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.key_value.insert(key, value);
                },
                32 => {
                    self.m_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.inversed = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.required = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trigger {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.pure_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for (k, v) in &self.key_value {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.m_type {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.inversed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.required {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trigger {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.pure_string.as_ref() {
            os.write_string(2, v)?;
        }
        for (k, v) in &self.key_value {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.m_type {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inversed {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchUpdate {
        MatchUpdate::new()
    }

    fn clear(&mut self) {
        self.trigger = ::std::option::Option::None;
        self.pure_string = ::std::option::Option::None;
        self.key_value.clear();
        self.m_type = ::std::option::Option::None;
        self.inversed = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchUpdate {
        static instance: ::protobuf::rt::Lazy<MatchUpdate> = ::protobuf::rt::Lazy::new();
        instance.get(MatchUpdate::new)
    }
}

impl ::protobuf::MessageFull for MatchUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ! DELETE PAGE RULE !
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeletePageRuleSchema)
pub struct DeletePageRuleSchema {
    // message fields
    // @@protoc_insertion_point(field:DeletePageRuleSchema.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:DeletePageRuleSchema.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:DeletePageRuleSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeletePageRuleSchema {
    fn default() -> &'a DeletePageRuleSchema {
        <DeletePageRuleSchema as ::protobuf::Message>::default_instance()
    }
}

impl DeletePageRuleSchema {
    pub fn new() -> DeletePageRuleSchema {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &DeletePageRuleSchema| { &m.domain },
            |m: &mut DeletePageRuleSchema| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeletePageRuleSchema| { &m.id },
            |m: &mut DeletePageRuleSchema| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeletePageRuleSchema>(
            "DeletePageRuleSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeletePageRuleSchema {
    const NAME: &'static str = "DeletePageRuleSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeletePageRuleSchema {
        DeletePageRuleSchema::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeletePageRuleSchema {
        static instance: DeletePageRuleSchema = DeletePageRuleSchema {
            domain: ::std::string::String::new(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeletePageRuleSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeletePageRuleSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeletePageRuleSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePageRuleSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Action)
pub enum Action {
    // @@protoc_insertion_point(enum_value:Action.Monopoly)
    Monopoly = 0,
    // @@protoc_insertion_point(enum_value:Action.Trustbusting)
    Trustbusting = 1,
}

impl ::protobuf::Enum for Action {
    const NAME: &'static str = "Action";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Action> {
        match value {
            0 => ::std::option::Option::Some(Action::Monopoly),
            1 => ::std::option::Option::Some(Action::Trustbusting),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Action] = &[
        Action::Monopoly,
        Action::Trustbusting,
    ];
}

impl ::protobuf::EnumFull for Action {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Action").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Action {
    fn default() -> Self {
        Action::Monopoly
    }
}

impl Action {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Action>("Action")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MonopolyAction)
pub enum MonopolyAction {
    // @@protoc_insertion_point(enum_value:MonopolyAction.Block)
    Block = 0,
}

impl ::protobuf::Enum for MonopolyAction {
    const NAME: &'static str = "MonopolyAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MonopolyAction> {
        match value {
            0 => ::std::option::Option::Some(MonopolyAction::Block),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MonopolyAction] = &[
        MonopolyAction::Block,
    ];
}

impl ::protobuf::EnumFull for MonopolyAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MonopolyAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MonopolyAction {
    fn default() -> Self {
        MonopolyAction::Block
    }
}

impl MonopolyAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MonopolyAction>("MonopolyAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CacheLevel)
pub enum CacheLevel {
    // @@protoc_insertion_point(enum_value:CacheLevel.None)
    None = 0,
    // @@protoc_insertion_point(enum_value:CacheLevel.Standard)
    Standard = 1,
    // @@protoc_insertion_point(enum_value:CacheLevel.IgnoreQueryString)
    IgnoreQueryString = 2,
    // @@protoc_insertion_point(enum_value:CacheLevel.Aggressive)
    Aggressive = 3,
}

impl ::protobuf::Enum for CacheLevel {
    const NAME: &'static str = "CacheLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheLevel> {
        match value {
            0 => ::std::option::Option::Some(CacheLevel::None),
            1 => ::std::option::Option::Some(CacheLevel::Standard),
            2 => ::std::option::Option::Some(CacheLevel::IgnoreQueryString),
            3 => ::std::option::Option::Some(CacheLevel::Aggressive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CacheLevel] = &[
        CacheLevel::None,
        CacheLevel::Standard,
        CacheLevel::IgnoreQueryString,
        CacheLevel::Aggressive,
    ];
}

impl ::protobuf::EnumFull for CacheLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CacheLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CacheLevel {
    fn default() -> Self {
        CacheLevel::None
    }
}

impl CacheLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CacheLevel>("CacheLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TrustBustOption)
pub enum TrustBustOption {
    // @@protoc_insertion_point(enum_value:TrustBustOption.SmartChallenge)
    SmartChallenge = 0,
    // @@protoc_insertion_point(enum_value:TrustBustOption.CaptchaChallenge)
    CaptchaChallenge = 1,
    // @@protoc_insertion_point(enum_value:TrustBustOption.RatelimitBucket)
    RatelimitBucket = 2,
    // @@protoc_insertion_point(enum_value:TrustBustOption.Cache)
    Cache = 3,
    // @@protoc_insertion_point(enum_value:TrustBustOption.Redirect)
    Redirect = 4,
    // @@protoc_insertion_point(enum_value:TrustBustOption.UseBackend)
    UseBackend = 5,
}

impl ::protobuf::Enum for TrustBustOption {
    const NAME: &'static str = "TrustBustOption";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrustBustOption> {
        match value {
            0 => ::std::option::Option::Some(TrustBustOption::SmartChallenge),
            1 => ::std::option::Option::Some(TrustBustOption::CaptchaChallenge),
            2 => ::std::option::Option::Some(TrustBustOption::RatelimitBucket),
            3 => ::std::option::Option::Some(TrustBustOption::Cache),
            4 => ::std::option::Option::Some(TrustBustOption::Redirect),
            5 => ::std::option::Option::Some(TrustBustOption::UseBackend),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrustBustOption] = &[
        TrustBustOption::SmartChallenge,
        TrustBustOption::CaptchaChallenge,
        TrustBustOption::RatelimitBucket,
        TrustBustOption::Cache,
        TrustBustOption::Redirect,
        TrustBustOption::UseBackend,
    ];
}

impl ::protobuf::EnumFull for TrustBustOption {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrustBustOption").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrustBustOption {
    fn default() -> Self {
        TrustBustOption::SmartChallenge
    }
}

impl TrustBustOption {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrustBustOption>("TrustBustOption")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TriggerType)
pub enum TriggerType {
    // @@protoc_insertion_point(enum_value:TriggerType.Ip)
    Ip = 0,
    // @@protoc_insertion_point(enum_value:TriggerType.Path)
    Path = 1,
    // @@protoc_insertion_point(enum_value:TriggerType.Query)
    Query = 2,
    // @@protoc_insertion_point(enum_value:TriggerType.Asn)
    Asn = 3,
    // @@protoc_insertion_point(enum_value:TriggerType.Country)
    Country = 4,
    // @@protoc_insertion_point(enum_value:TriggerType.Continent)
    Continent = 5,
    // @@protoc_insertion_point(enum_value:TriggerType.Headers)
    Headers = 6,
}

impl ::protobuf::Enum for TriggerType {
    const NAME: &'static str = "TriggerType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TriggerType> {
        match value {
            0 => ::std::option::Option::Some(TriggerType::Ip),
            1 => ::std::option::Option::Some(TriggerType::Path),
            2 => ::std::option::Option::Some(TriggerType::Query),
            3 => ::std::option::Option::Some(TriggerType::Asn),
            4 => ::std::option::Option::Some(TriggerType::Country),
            5 => ::std::option::Option::Some(TriggerType::Continent),
            6 => ::std::option::Option::Some(TriggerType::Headers),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TriggerType] = &[
        TriggerType::Ip,
        TriggerType::Path,
        TriggerType::Query,
        TriggerType::Asn,
        TriggerType::Country,
        TriggerType::Continent,
        TriggerType::Headers,
    ];
}

impl ::protobuf::EnumFull for TriggerType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TriggerType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TriggerType {
    fn default() -> Self {
        TriggerType::Ip
    }
}

impl TriggerType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TriggerType>("TriggerType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MatchType)
pub enum MatchType {
    // @@protoc_insertion_point(enum_value:MatchType.Exact)
    Exact = 0,
    // @@protoc_insertion_point(enum_value:MatchType.Contains)
    Contains = 1,
    // @@protoc_insertion_point(enum_value:MatchType.StartsWith)
    StartsWith = 2,
}

impl ::protobuf::Enum for MatchType {
    const NAME: &'static str = "MatchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchType::Exact),
            1 => ::std::option::Option::Some(MatchType::Contains),
            2 => ::std::option::Option::Some(MatchType::StartsWith),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchType] = &[
        MatchType::Exact,
        MatchType::Contains,
        MatchType::StartsWith,
    ];
}

impl ::protobuf::EnumFull for MatchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MatchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MatchType {
    fn default() -> Self {
        MatchType::Exact
    }
}

impl MatchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatchType>("MatchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TriggerRequirement)
pub enum TriggerRequirement {
    // @@protoc_insertion_point(enum_value:TriggerRequirement.One)
    One = 0,
    // @@protoc_insertion_point(enum_value:TriggerRequirement.All)
    All = 1,
}

impl ::protobuf::Enum for TriggerRequirement {
    const NAME: &'static str = "TriggerRequirement";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TriggerRequirement> {
        match value {
            0 => ::std::option::Option::Some(TriggerRequirement::One),
            1 => ::std::option::Option::Some(TriggerRequirement::All),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TriggerRequirement] = &[
        TriggerRequirement::One,
        TriggerRequirement::All,
    ];
}

impl ::protobuf::EnumFull for TriggerRequirement {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TriggerRequirement").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TriggerRequirement {
    fn default() -> Self {
        TriggerRequirement::One
    }
}

impl TriggerRequirement {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TriggerRequirement>("TriggerRequirement")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10page_rules.proto\")\n\rQueryResponse\x12\x18\n\x07success\x18\x01\
    \x20\x01(\x08R\x07success\"F\n\x12EnableStatusUpdate\x12\x16\n\x06domain\
    \x18\x01\x20\x01(\tR\x06domain\x12\x18\n\x07enabled\x18\x02\x20\x01(\x08\
    R\x07enabled\"\x97\x05\n\x0bNewPageRule\x12\x16\n\x06domain\x18\x01\x20\
    \x01(\tR\x06domain\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x19\n\
    \x05order\x18\x03\x20\x01(\x11H\0R\x05order\x88\x01\x01\x12(\n\nmatch_ty\
    pe\x18\x04\x20\x03(\x0b2\t.MatchNewR\tmatchType\x12D\n\x13trigger_requir\
    ement\x18\x05\x20\x01(\x0e2\x13.TriggerRequirementR\x12triggerRequiremen\
    t\x12\x1a\n\x08inversed\x18\x06\x20\x01(\x08R\x08inversed\x12\x1f\n\x06a\
    ction\x18\x07\x20\x01(\x0e2\x07.ActionR\x06action\x120\n\x08monopoly\x18\
    \x08\x20\x01(\x0e2\x0f.MonopolyActionH\x01R\x08monopoly\x88\x01\x01\x12.\
    \n\ttrustbust\x18\t\x20\x03(\x0e2\x10.TrustBustOptionR\ttrustbust\x12$\n\
    \x0bbucket_name\x18\n\x20\x01(\tH\x02R\nbucketName\x88\x01\x01\x121\n\
    \x0bcache_level\x18\x0b\x20\x01(\x0e2\x0b.CacheLevelH\x03R\ncacheLevel\
    \x88\x01\x01\x12/\n\x11default_cache_ttl\x18\x0c\x20\x01(\x11H\x04R\x0fd\
    efaultCacheTtl\x88\x01\x01\x12\x1f\n\x08redirect\x18\r\x20\x01(\tH\x05R\
    \x08redirect\x88\x01\x01\x12\"\n\nbackend_id\x18\x0e\x20\x01(\tH\x06R\tb\
    ackendId\x88\x01\x01B\x08\n\x06_orderB\x0b\n\t_monopolyB\x0e\n\x0c_bucke\
    t_nameB\x0e\n\x0c_cache_levelB\x14\n\x12_default_cache_ttlB\x0b\n\t_redi\
    rectB\r\n\x0b_backend_id\"\xe0\x01\n\x08MatchNew\x12&\n\x07trigger\x18\
    \x01\x20\x01(\x0e2\x0c.TriggerTypeR\x07trigger\x12$\n\x0bpure_string\x18\
    \x02\x20\x01(\tH\0R\npureString\x88\x01\x01\x12\x1b\n\tkey_value\x18\x03\
    \x20\x03(\tR\x08keyValue\x12!\n\x06m_type\x18\x04\x20\x01(\x0e2\n.MatchT\
    ypeR\x05mType\x12\x1a\n\x08inversed\x18\x05\x20\x01(\x08R\x08inversed\
    \x12\x1a\n\x08required\x18\x06\x20\x01(\x08R\x08requiredB\x0e\n\x0c_pure\
    _string\"\xdf\x05\n\x14UpdatePageRuleSchema\x12\x16\n\x06domain\x18\x01\
    \x20\x01(\tR\x06domain\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x19\
    \n\x05order\x18\x03\x20\x01(\x11H\0R\x05order\x88\x01\x01\x12(\n\nmatch_\
    type\x18\x04\x20\x03(\x0b2\t.MatchNewR\tmatchType\x12I\n\x13trigger_requ\
    irement\x18\x05\x20\x01(\x0e2\x13.TriggerRequirementH\x01R\x12triggerReq\
    uirement\x88\x01\x01\x12\x1f\n\x08inversed\x18\x06\x20\x01(\x08H\x02R\
    \x08inversed\x88\x01\x01\x12$\n\x06action\x18\x07\x20\x01(\x0e2\x07.Acti\
    onH\x03R\x06action\x88\x01\x01\x120\n\x08monopoly\x18\x08\x20\x01(\x0e2\
    \x0f.MonopolyActionH\x04R\x08monopoly\x88\x01\x01\x12.\n\ttrustbust\x18\
    \t\x20\x03(\x0e2\x10.TrustBustOptionR\ttrustbust\x12$\n\x0bbucket_name\
    \x18\n\x20\x01(\tH\x05R\nbucketName\x88\x01\x01\x121\n\x0bcache_level\
    \x18\x0b\x20\x01(\x0e2\x0b.CacheLevelH\x06R\ncacheLevel\x88\x01\x01\x12/\
    \n\x11default_cache_ttl\x18\x0c\x20\x01(\x11H\x07R\x0fdefaultCacheTtl\
    \x88\x01\x01\x12\x1f\n\x08redirect\x18\r\x20\x01(\tH\x08R\x08redirect\
    \x88\x01\x01\x12\"\n\nbackend_id\x18\x0e\x20\x01(\tH\tR\tbackendId\x88\
    \x01\x01B\x08\n\x06_orderB\x16\n\x14_trigger_requirementB\x0b\n\t_invers\
    edB\t\n\x07_actionB\x0b\n\t_monopolyB\x0e\n\x0c_bucket_nameB\x0e\n\x0c_c\
    ache_levelB\x14\n\x12_default_cache_ttlB\x0b\n\t_redirectB\r\n\x0b_backe\
    nd_id\"\x81\x03\n\x0bMatchUpdate\x12+\n\x07trigger\x18\x01\x20\x01(\x0e2\
    \x0c.TriggerTypeH\0R\x07trigger\x88\x01\x01\x12$\n\x0bpure_string\x18\
    \x02\x20\x01(\tH\x01R\npureString\x88\x01\x01\x127\n\tkey_value\x18\x03\
    \x20\x03(\x0b2\x1a.MatchUpdate.KeyValueEntryR\x08keyValue\x12&\n\x06m_ty\
    pe\x18\x04\x20\x01(\x0e2\n.MatchTypeH\x02R\x05mType\x88\x01\x01\x12\x1f\
    \n\x08inversed\x18\x05\x20\x01(\x08H\x03R\x08inversed\x88\x01\x01\x12\
    \x1f\n\x08required\x18\x06\x20\x01(\x08H\x04R\x08required\x88\x01\x01\
    \x1a;\n\rKeyValueEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\n\n\x08_triggerB\
    \x0e\n\x0c_pure_stringB\t\n\x07_m_typeB\x0b\n\t_inversedB\x0b\n\t_requir\
    ed\">\n\x14DeletePageRuleSchema\x12\x16\n\x06domain\x18\x01\x20\x01(\tR\
    \x06domain\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id*(\n\x06Action\x12\
    \x0c\n\x08Monopoly\x10\0\x12\x10\n\x0cTrustbusting\x10\x01*\x1b\n\x0eMon\
    opolyAction\x12\t\n\x05Block\x10\0*K\n\nCacheLevel\x12\x08\n\x04None\x10\
    \0\x12\x0c\n\x08Standard\x10\x01\x12\x15\n\x11IgnoreQueryString\x10\x02\
    \x12\x0e\n\nAggressive\x10\x03*y\n\x0fTrustBustOption\x12\x12\n\x0eSmart\
    Challenge\x10\0\x12\x14\n\x10CaptchaChallenge\x10\x01\x12\x13\n\x0fRatel\
    imitBucket\x10\x02\x12\t\n\x05Cache\x10\x03\x12\x0c\n\x08Redirect\x10\
    \x04\x12\x0e\n\nUseBackend\x10\x05*\\\n\x0bTriggerType\x12\x06\n\x02Ip\
    \x10\0\x12\x08\n\x04Path\x10\x01\x12\t\n\x05Query\x10\x02\x12\x07\n\x03A\
    sn\x10\x03\x12\x0b\n\x07Country\x10\x04\x12\r\n\tContinent\x10\x05\x12\
    \x0b\n\x07Headers\x10\x06*4\n\tMatchType\x12\t\n\x05Exact\x10\0\x12\x0c\
    \n\x08Contains\x10\x01\x12\x0e\n\nStartsWith\x10\x02*&\n\x12TriggerRequi\
    rement\x12\x07\n\x03One\x10\0\x12\x07\n\x03All\x10\x012\xeb\x01\n\x0fPag\
    eRulesEngine\x129\n\x12ChangeEnableStatus\x12\x13.EnableStatusUpdate\x1a\
    \x0e.QueryResponse\x12+\n\x0bAddPageRule\x12\x0c.NewPageRule\x1a\x0e.Que\
    ryResponse\x127\n\x0eUpdatePageRule\x12\x15.UpdatePageRuleSchema\x1a\x0e\
    .QueryResponse\x127\n\x0eDeletePageRule\x12\x15.DeletePageRuleSchema\x1a\
    \x0e.QueryResponseJ\xef(\n\x07\x12\x05\0\0\x8d\x01\x01\n\x08\n\x01\x0c\
    \x12\x03\0\0\x12\n\n\n\x02\x06\0\x12\x04\x02\0\x08\x01\n\n\n\x03\x06\0\
    \x01\x12\x03\x02\x08\x17\n\x0b\n\x04\x06\0\x02\0\x12\x03\x03\x02E\n\x0c\
    \n\x05\x06\0\x02\0\x01\x12\x03\x03\x06\x18\n\x0c\n\x05\x06\0\x02\0\x02\
    \x12\x03\x03\x19+\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x036C\n\x0b\n\x04\
    \x06\0\x02\x01\x12\x03\x05\x027\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\
    \x05\x06\x11\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x05\x12\x1d\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03\x05(5\n\x0b\n\x04\x06\0\x02\x02\x12\x03\
    \x06\x02C\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x06\x06\x14\n\x0c\n\x05\
    \x06\0\x02\x02\x02\x12\x03\x06\x15)\n\x0c\n\x05\x06\0\x02\x02\x03\x12\
    \x03\x064A\n\x0b\n\x04\x06\0\x02\x03\x12\x03\x07\x02C\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03\x07\x06\x14\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\
    \x07\x15)\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x074A\n\n\n\x02\x04\0\
    \x12\x04\n\0\x0c\x01\n\n\n\x03\x04\0\x01\x12\x03\n\x08\x15\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x0b\x02\x13\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0b\
    \x02\x06\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0b\x07\x0e\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03\x0b\x11\x12\n\n\n\x02\x04\x01\x12\x04\x0e\0\x11\x01\
    \n\n\n\x03\x04\x01\x01\x12\x03\x0e\x08\x1a\n\x0b\n\x04\x04\x01\x02\0\x12\
    \x03\x0f\x02\x14\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x0f\x02\x08\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03\x0f\t\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x0f\x12\x13\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x10\x02\x13\n\
    \x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x10\x02\x06\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03\x10\x07\x0e\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\
    \x10\x11\x12\n\x1f\n\x02\x04\x02\x12\x04\x14\0*\x01\x1a\x13\x20!\x20NEW\
    \x20PAGE\x20RULE\x20!\n\n\n\n\x03\x04\x02\x01\x12\x03\x14\x08\x13\n#\n\
    \x04\x04\x02\x02\0\x12\x03\x16\x02\x14\x1a\x16\x20required\x20informatio\
    n\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03\x16\t\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\
    \x16\x12\x13\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x17\x02\x10\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03\x17\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03\x17\t\x0b\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x17\x0e\x0f\n\
    (\n\x04\x04\x02\x02\x02\x12\x03\x18\x02\x1c\"\x1b\x20the\x20order\x20it\
    \x20should\x20be\x20in\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03\x18\x02\
    \n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\x18\x0b\x11\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03\x18\x12\x17\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\
    \x03\x18\x1a\x1b\n\x16\n\x04\x04\x02\x02\x03\x12\x03\x1a\x02#\x1a\t\x20t\
    rigger\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03\x1a\x02\n\n\x0c\n\x05\
    \x04\x02\x02\x03\x06\x12\x03\x1a\x0b\x13\n\x0c\n\x05\x04\x02\x02\x03\x01\
    \x12\x03\x1a\x14\x1e\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x1a!\"\n\
    \x0b\n\x04\x04\x02\x02\x04\x12\x03\x1b\x02-\n\x0c\n\x05\x04\x02\x02\x04\
    \x06\x12\x03\x1b\x02\x14\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x1b\x15\
    (\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x1b+,\n\x0b\n\x04\x04\x02\x02\
    \x05\x12\x03\x1c\x02\x14\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03\x1c\x02\
    \x06\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03\x1c\x07\x0f\n\x0c\n\x05\x04\
    \x02\x02\x05\x03\x12\x03\x1c\x12\x13\n\x15\n\x04\x04\x02\x02\x06\x12\x03\
    \x1e\x02\x14\x1a\x08\x20action\n\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03\
    \x1e\x02\x08\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03\x1e\t\x0f\n\x0c\n\
    \x05\x04\x02\x02\x06\x03\x12\x03\x1e\x12\x13\n\x0b\n\x04\x04\x02\x02\x07\
    \x12\x03\x1f\x02'\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03\x1f\x02\n\n\
    \x0c\n\x05\x04\x02\x02\x07\x06\x12\x03\x1f\x0b\x19\n\x0c\n\x05\x04\x02\
    \x02\x07\x01\x12\x03\x1f\x1a\"\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03\
    \x1f%&\n\x17\n\x04\x04\x02\x02\x08\x12\x03\x20\x02)\"\n\x20optional\n\n\
    \x0c\n\x05\x04\x02\x02\x08\x04\x12\x03\x20\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x08\x06\x12\x03\x20\x0b\x1a\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03\x20\
    \x1b$\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03\x20'(\n&\n\x04\x04\x02\x02\
    \t\x12\x03\"\x02#\x1a\x19\x20optional\x20action\x20options\n\n\x0c\n\x05\
    \x04\x02\x02\t\x04\x12\x03\"\x02\n\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03\
    \"\x0b\x11\n\x0c\n\x05\x04\x02\x02\t\x01\x12\x03\"\x12\x1d\n\x0c\n\x05\
    \x04\x02\x02\t\x03\x12\x03\"\x20\"\n\x16\n\x04\x04\x02\x02\n\x12\x03$\
    \x02'\x1a\t\x20caching\n\n\x0c\n\x05\x04\x02\x02\n\x04\x12\x03$\x02\n\n\
    \x0c\n\x05\x04\x02\x02\n\x06\x12\x03$\x0b\x15\n\x0c\n\x05\x04\x02\x02\n\
    \x01\x12\x03$\x16!\n\x0c\n\x05\x04\x02\x02\n\x03\x12\x03$$&\n\x0b\n\x04\
    \x04\x02\x02\x0b\x12\x03%\x02)\n\x0c\n\x05\x04\x02\x02\x0b\x04\x12\x03%\
    \x02\n\n\x0c\n\x05\x04\x02\x02\x0b\x05\x12\x03%\x0b\x11\n\x0c\n\x05\x04\
    \x02\x02\x0b\x01\x12\x03%\x12#\n\x0c\n\x05\x04\x02\x02\x0b\x03\x12\x03%&\
    (\n\x1a\n\x04\x04\x02\x02\x0c\x12\x03'\x02\x20\x1a\r\x20redirect\x20to\n\
    \n\x0c\n\x05\x04\x02\x02\x0c\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x0c\x05\x12\x03'\x0b\x11\n\x0c\n\x05\x04\x02\x02\x0c\x01\x12\x03'\x12\
    \x1a\n\x0c\n\x05\x04\x02\x02\x0c\x03\x12\x03'\x1d\x1f\n(\n\x04\x04\x02\
    \x02\r\x12\x03)\x02\"\x1a\x1b\x20use\x20backend,\x20fetch\x20its\x20id\n\
    \n\x0c\n\x05\x04\x02\x02\r\x04\x12\x03)\x02\n\n\x0c\n\x05\x04\x02\x02\r\
    \x05\x12\x03)\x0b\x11\n\x0c\n\x05\x04\x02\x02\r\x01\x12\x03)\x12\x1c\n\
    \x0c\n\x05\x04\x02\x02\r\x03\x12\x03)\x1f!\n\n\n\x02\x04\x03\x12\x04,\03\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03,\x08\x10\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x03-\x02\x1a\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03-\x02\r\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x03-\x0e\x15\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03-\x18\x19\n.\n\x04\x04\x03\x02\x01\x12\x03.\x02\"\"!\x20pure\x20\
    string\x20that\x20comes\x20attached\n\n\x0c\n\x05\x04\x03\x02\x01\x04\
    \x12\x03.\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03.\x0b\x11\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03.\x12\x1d\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03.\x20!\n?\n\x04\x04\x03\x02\x02\x12\x03/\x02\x20\"2\x20map\
    \x20is\x20optional.\x200th\x20entry\x20is\x20key,\x201st\x20is\x20value!\
    \n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03/\x02\n\n\x0c\n\x05\x04\x03\
    \x02\x02\x05\x12\x03/\x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03/\
    \x12\x1b\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03/\x1e\x1f\n\x0b\n\x04\
    \x04\x03\x02\x03\x12\x030\x02\x17\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\
    \x030\x02\x0b\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x030\x0c\x12\n\x0c\n\
    \x05\x04\x03\x02\x03\x03\x12\x030\x15\x16\n\x0b\n\x04\x04\x03\x02\x04\
    \x12\x031\x02\x14\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x031\x02\x06\n\x0c\
    \n\x05\x04\x03\x02\x04\x01\x12\x031\x07\x0f\n\x0c\n\x05\x04\x03\x02\x04\
    \x03\x12\x031\x12\x13\n\x0b\n\x04\x04\x03\x02\x05\x12\x032\x02\x14\n\x0c\
    \n\x05\x04\x03\x02\x05\x05\x12\x032\x02\x06\n\x0c\n\x05\x04\x03\x02\x05\
    \x01\x12\x032\x07\x0f\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x032\x12\x13\n\
    \"\n\x02\x04\x04\x12\x047\0M\x01\x1a\x16\x20!\x20UPDATE\x20PAGE\x20RULE\
    \x20!\n\n\n\n\x03\x04\x04\x01\x12\x037\x08\x1c\n#\n\x04\x04\x04\x02\0\
    \x12\x039\x02\x14\x1a\x16\x20required\x20information\n\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x039\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x039\t\
    \x0f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x039\x12\x13\n\x0b\n\x04\x04\x04\
    \x02\x01\x12\x03:\x02\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03:\x02\
    \x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03:\t\x0b\n\x0c\n\x05\x04\x04\
    \x02\x01\x03\x12\x03:\x0e\x0f\n(\n\x04\x04\x04\x02\x02\x12\x03;\x02\x1c\
    \"\x1b\x20the\x20order\x20it\x20should\x20be\x20in\n\n\x0c\n\x05\x04\x04\
    \x02\x02\x04\x12\x03;\x02\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03;\x0b\
    \x11\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03;\x12\x17\n\x0c\n\x05\x04\
    \x04\x02\x02\x03\x12\x03;\x1a\x1b\n6\n\x04\x04\x04\x02\x03\x12\x03=\x02#\
    \x1a\t\x20trigger\n\"\x1e\x20repeated\x20makes\x20this\x20optional\n\n\
    \x0c\n\x05\x04\x04\x02\x03\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x03\x06\x12\x03=\x0b\x13\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03=\x14\
    \x1e\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03=!\"\n\x0b\n\x04\x04\x04\x02\
    \x04\x12\x03>\x026\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03>\x02\n\n\x0c\
    \n\x05\x04\x04\x02\x04\x06\x12\x03>\x0b\x1d\n\x0c\n\x05\x04\x04\x02\x04\
    \x01\x12\x03>\x1e1\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03>45\n\x0b\n\
    \x04\x04\x04\x02\x05\x12\x03?\x02\x1d\n\x0c\n\x05\x04\x04\x02\x05\x04\
    \x12\x03?\x02\n\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03?\x0b\x0f\n\x0c\n\
    \x05\x04\x04\x02\x05\x01\x12\x03?\x10\x18\n\x0c\n\x05\x04\x04\x02\x05\
    \x03\x12\x03?\x1b\x1c\n\x15\n\x04\x04\x04\x02\x06\x12\x03A\x02\x1d\x1a\
    \x08\x20action\n\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03A\x02\n\n\x0c\n\
    \x05\x04\x04\x02\x06\x06\x12\x03A\x0b\x11\n\x0c\n\x05\x04\x04\x02\x06\
    \x01\x12\x03A\x12\x18\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03A\x1b\x1c\n\
    \x0b\n\x04\x04\x04\x02\x07\x12\x03B\x02'\n\x0c\n\x05\x04\x04\x02\x07\x04\
    \x12\x03B\x02\n\n\x0c\n\x05\x04\x04\x02\x07\x06\x12\x03B\x0b\x19\n\x0c\n\
    \x05\x04\x04\x02\x07\x01\x12\x03B\x1a\"\n\x0c\n\x05\x04\x04\x02\x07\x03\
    \x12\x03B%&\n\x17\n\x04\x04\x04\x02\x08\x12\x03C\x02)\"\n\x20optional\n\
    \n\x0c\n\x05\x04\x04\x02\x08\x04\x12\x03C\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x08\x06\x12\x03C\x0b\x1a\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\x03C\x1b$\
    \n\x0c\n\x05\x04\x04\x02\x08\x03\x12\x03C'(\n&\n\x04\x04\x04\x02\t\x12\
    \x03E\x02#\x1a\x19\x20optional\x20action\x20options\n\n\x0c\n\x05\x04\
    \x04\x02\t\x04\x12\x03E\x02\n\n\x0c\n\x05\x04\x04\x02\t\x05\x12\x03E\x0b\
    \x11\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03E\x12\x1d\n\x0c\n\x05\x04\x04\
    \x02\t\x03\x12\x03E\x20\"\n\x16\n\x04\x04\x04\x02\n\x12\x03G\x02'\x1a\t\
    \x20caching\n\n\x0c\n\x05\x04\x04\x02\n\x04\x12\x03G\x02\n\n\x0c\n\x05\
    \x04\x04\x02\n\x06\x12\x03G\x0b\x15\n\x0c\n\x05\x04\x04\x02\n\x01\x12\
    \x03G\x16!\n\x0c\n\x05\x04\x04\x02\n\x03\x12\x03G$&\n\x0b\n\x04\x04\x04\
    \x02\x0b\x12\x03H\x02)\n\x0c\n\x05\x04\x04\x02\x0b\x04\x12\x03H\x02\n\n\
    \x0c\n\x05\x04\x04\x02\x0b\x05\x12\x03H\x0b\x11\n\x0c\n\x05\x04\x04\x02\
    \x0b\x01\x12\x03H\x12#\n\x0c\n\x05\x04\x04\x02\x0b\x03\x12\x03H&(\n\x1a\
    \n\x04\x04\x04\x02\x0c\x12\x03J\x02\x20\x1a\r\x20redirect\x20to\n\n\x0c\
    \n\x05\x04\x04\x02\x0c\x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x04\x02\x0c\
    \x05\x12\x03J\x0b\x11\n\x0c\n\x05\x04\x04\x02\x0c\x01\x12\x03J\x12\x1a\n\
    \x0c\n\x05\x04\x04\x02\x0c\x03\x12\x03J\x1d\x1f\n(\n\x04\x04\x04\x02\r\
    \x12\x03L\x02\"\x1a\x1b\x20use\x20backend,\x20fetch\x20its\x20id\n\n\x0c\
    \n\x05\x04\x04\x02\r\x04\x12\x03L\x02\n\n\x0c\n\x05\x04\x04\x02\r\x05\
    \x12\x03L\x0b\x11\n\x0c\n\x05\x04\x04\x02\r\x01\x12\x03L\x12\x1c\n\x0c\n\
    \x05\x04\x04\x02\r\x03\x12\x03L\x1f!\n\n\n\x02\x04\x05\x12\x04O\0V\x01\n\
    \n\n\x03\x04\x05\x01\x12\x03O\x08\x13\n\x0b\n\x04\x04\x05\x02\0\x12\x03P\
    \x02#\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\x05\
    \x02\0\x06\x12\x03P\x0b\x16\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03P\x17\
    \x1e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03P!\"\n.\n\x04\x04\x05\x02\x01\
    \x12\x03Q\x02\"\"!\x20pure\x20string\x20that\x20comes\x20attached\n\n\
    \x0c\n\x05\x04\x05\x02\x01\x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\x05\x02\
    \x01\x05\x12\x03Q\x0b\x11\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03Q\x12\
    \x1d\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03Q\x20!\n?\n\x04\x04\x05\x02\
    \x02\x12\x03R\x02$\"2\x20map\x20is\x20optional.\x200th\x20entry\x20is\
    \x20key,\x201st\x20is\x20value!\n\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\
    \x03R\x02\x15\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03R\x16\x1f\n\x0c\n\
    \x05\x04\x05\x02\x02\x03\x12\x03R\"#\n\x0b\n\x04\x04\x05\x02\x03\x12\x03\
    S\x02\x20\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\
    \x05\x02\x03\x06\x12\x03S\x0b\x14\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\
    \x03S\x15\x1b\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03S\x1e\x1f\n\x0b\n\
    \x04\x04\x05\x02\x04\x12\x03T\x02\x1d\n\x0c\n\x05\x04\x05\x02\x04\x04\
    \x12\x03T\x02\n\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03T\x0b\x0f\n\x0c\n\
    \x05\x04\x05\x02\x04\x01\x12\x03T\x10\x18\n\x0c\n\x05\x04\x05\x02\x04\
    \x03\x12\x03T\x1b\x1c\n\x0b\n\x04\x04\x05\x02\x05\x12\x03U\x02\x1d\n\x0c\
    \n\x05\x04\x05\x02\x05\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\x05\x02\x05\
    \x05\x12\x03U\x0b\x0f\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03U\x10\x18\n\
    \x0c\n\x05\x04\x05\x02\x05\x03\x12\x03U\x1b\x1c\n\"\n\x02\x04\x06\x12\
    \x04Z\0^\x01\x1a\x16\x20!\x20DELETE\x20PAGE\x20RULE\x20!\n\n\n\n\x03\x04\
    \x06\x01\x12\x03Z\x08\x1c\n\x0b\n\x04\x04\x06\x02\0\x12\x03[\x02\x14\n\
    \x0c\n\x05\x04\x06\x02\0\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03[\t\x0f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03[\x12\x13\np\n\
    \x04\x04\x06\x02\x01\x12\x03\\\x02\x10\"c\x20when\x20it\x20gets\x20poppe\
    d\x20out,\x20the\x20order\x20automatically\x20shifts\x20(this\x20should\
    \x20be\x20done\x20on\x20the\x20API\x20side\x20too)\n\n\x0c\n\x05\x04\x06\
    \x02\x01\x05\x12\x03\\\x02\x08\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03\\\
    \t\x0b\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03\\\x0e\x0f\n\n\n\x02\x05\0\
    \x12\x04a\0d\x01\n\n\n\x03\x05\0\x01\x12\x03a\x05\x0b\n\x0b\n\x04\x05\0\
    \x02\0\x12\x03b\x02\x0f\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03b\x02\n\n\x0c\
    \n\x05\x05\0\x02\0\x02\x12\x03b\r\x0e\n\x0b\n\x04\x05\0\x02\x01\x12\x03c\
    \x02\x13\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03c\x02\x0e\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03c\x11\x12\n\n\n\x02\x05\x01\x12\x04f\0h\x01\n\n\n\
    \x03\x05\x01\x01\x12\x03f\x05\x13\n\x0b\n\x04\x05\x01\x02\0\x12\x03g\x02\
    \x0c\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03g\x02\x07\n\x0c\n\x05\x05\x01\
    \x02\0\x02\x12\x03g\n\x0b\n\n\n\x02\x05\x02\x12\x04j\0o\x01\n\n\n\x03\
    \x05\x02\x01\x12\x03j\x05\x0f\n\x0b\n\x04\x05\x02\x02\0\x12\x03k\x02\x0b\
    \n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03k\x02\x06\n\x0c\n\x05\x05\x02\x02\
    \0\x02\x12\x03k\t\n\n\x0b\n\x04\x05\x02\x02\x01\x12\x03l\x02\x0f\n\x0c\n\
    \x05\x05\x02\x02\x01\x01\x12\x03l\x02\n\n\x0c\n\x05\x05\x02\x02\x01\x02\
    \x12\x03l\r\x0e\n\x0b\n\x04\x05\x02\x02\x02\x12\x03m\x02\x18\n\x0c\n\x05\
    \x05\x02\x02\x02\x01\x12\x03m\x02\x13\n\x0c\n\x05\x05\x02\x02\x02\x02\
    \x12\x03m\x16\x17\n\x0b\n\x04\x05\x02\x02\x03\x12\x03n\x02\x11\n\x0c\n\
    \x05\x05\x02\x02\x03\x01\x12\x03n\x02\x0c\n\x0c\n\x05\x05\x02\x02\x03\
    \x02\x12\x03n\x0f\x10\n\n\n\x02\x05\x03\x12\x04q\0x\x01\n\n\n\x03\x05\
    \x03\x01\x12\x03q\x05\x14\n\x0b\n\x04\x05\x03\x02\0\x12\x03r\x02\x15\n\
    \x0c\n\x05\x05\x03\x02\0\x01\x12\x03r\x02\x10\n\x0c\n\x05\x05\x03\x02\0\
    \x02\x12\x03r\x13\x14\n\x0b\n\x04\x05\x03\x02\x01\x12\x03s\x02\x17\n\x0c\
    \n\x05\x05\x03\x02\x01\x01\x12\x03s\x02\x12\n\x0c\n\x05\x05\x03\x02\x01\
    \x02\x12\x03s\x15\x16\n\x0b\n\x04\x05\x03\x02\x02\x12\x03t\x02\x16\n\x0c\
    \n\x05\x05\x03\x02\x02\x01\x12\x03t\x02\x11\n\x0c\n\x05\x05\x03\x02\x02\
    \x02\x12\x03t\x14\x15\n\x0b\n\x04\x05\x03\x02\x03\x12\x03u\x02\x0c\n\x0c\
    \n\x05\x05\x03\x02\x03\x01\x12\x03u\x02\x07\n\x0c\n\x05\x05\x03\x02\x03\
    \x02\x12\x03u\n\x0b\n\x0b\n\x04\x05\x03\x02\x04\x12\x03v\x02\x0f\n\x0c\n\
    \x05\x05\x03\x02\x04\x01\x12\x03v\x02\n\n\x0c\n\x05\x05\x03\x02\x04\x02\
    \x12\x03v\r\x0e\n\x0b\n\x04\x05\x03\x02\x05\x12\x03w\x02\x11\n\x0c\n\x05\
    \x05\x03\x02\x05\x01\x12\x03w\x02\x0c\n\x0c\n\x05\x05\x03\x02\x05\x02\
    \x12\x03w\x0f\x10\n\x0b\n\x02\x05\x04\x12\x05z\0\x82\x01\x01\n\n\n\x03\
    \x05\x04\x01\x12\x03z\x05\x10\n\x0b\n\x04\x05\x04\x02\0\x12\x03{\x02\t\n\
    \x0c\n\x05\x05\x04\x02\0\x01\x12\x03{\x02\x04\n\x0c\n\x05\x05\x04\x02\0\
    \x02\x12\x03{\x07\x08\n\x0b\n\x04\x05\x04\x02\x01\x12\x03|\x02\x0b\n\x0c\
    \n\x05\x05\x04\x02\x01\x01\x12\x03|\x02\x06\n\x0c\n\x05\x05\x04\x02\x01\
    \x02\x12\x03|\t\n\n\x0b\n\x04\x05\x04\x02\x02\x12\x03}\x02\x0c\n\x0c\n\
    \x05\x05\x04\x02\x02\x01\x12\x03}\x02\x07\n\x0c\n\x05\x05\x04\x02\x02\
    \x02\x12\x03}\n\x0b\n\x0b\n\x04\x05\x04\x02\x03\x12\x03~\x02\n\n\x0c\n\
    \x05\x05\x04\x02\x03\x01\x12\x03~\x02\x05\n\x0c\n\x05\x05\x04\x02\x03\
    \x02\x12\x03~\x08\t\n\x0b\n\x04\x05\x04\x02\x04\x12\x03\x7f\x02\x0e\n\
    \x0c\n\x05\x05\x04\x02\x04\x01\x12\x03\x7f\x02\t\n\x0c\n\x05\x05\x04\x02\
    \x04\x02\x12\x03\x7f\x0c\r\n\x0c\n\x04\x05\x04\x02\x05\x12\x04\x80\x01\
    \x02\x10\n\r\n\x05\x05\x04\x02\x05\x01\x12\x04\x80\x01\x02\x0b\n\r\n\x05\
    \x05\x04\x02\x05\x02\x12\x04\x80\x01\x0e\x0f\n\x0c\n\x04\x05\x04\x02\x06\
    \x12\x04\x81\x01\x02\x0e\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\x81\x01\
    \x02\t\n\r\n\x05\x05\x04\x02\x06\x02\x12\x04\x81\x01\x0c\r\n\x0c\n\x02\
    \x05\x05\x12\x06\x84\x01\0\x88\x01\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\
    \x84\x01\x05\x0e\n\x0c\n\x04\x05\x05\x02\0\x12\x04\x85\x01\x02\x0c\n\r\n\
    \x05\x05\x05\x02\0\x01\x12\x04\x85\x01\x02\x07\n\r\n\x05\x05\x05\x02\0\
    \x02\x12\x04\x85\x01\n\x0b\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\x86\x01\
    \x02\x0f\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\x86\x01\x02\n\n\r\n\x05\
    \x05\x05\x02\x01\x02\x12\x04\x86\x01\r\x0e\n\x0c\n\x04\x05\x05\x02\x02\
    \x12\x04\x87\x01\x02\x11\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\x87\x01\
    \x02\x0c\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\x87\x01\x0f\x10\n\x0c\n\
    \x02\x05\x06\x12\x06\x8a\x01\0\x8d\x01\x01\n\x0b\n\x03\x05\x06\x01\x12\
    \x04\x8a\x01\x05\x17\n\x0c\n\x04\x05\x06\x02\0\x12\x04\x8b\x01\x02\n\n\r\
    \n\x05\x05\x06\x02\0\x01\x12\x04\x8b\x01\x02\x05\n\r\n\x05\x05\x06\x02\0\
    \x02\x12\x04\x8b\x01\x08\t\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\x8c\x01\
    \x02\n\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\x8c\x01\x02\x05\n\r\n\x05\
    \x05\x06\x02\x01\x02\x12\x04\x8c\x01\x08\tb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(QueryResponse::generated_message_descriptor_data());
            messages.push(EnableStatusUpdate::generated_message_descriptor_data());
            messages.push(NewPageRule::generated_message_descriptor_data());
            messages.push(MatchNew::generated_message_descriptor_data());
            messages.push(UpdatePageRuleSchema::generated_message_descriptor_data());
            messages.push(MatchUpdate::generated_message_descriptor_data());
            messages.push(DeletePageRuleSchema::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(Action::generated_enum_descriptor_data());
            enums.push(MonopolyAction::generated_enum_descriptor_data());
            enums.push(CacheLevel::generated_enum_descriptor_data());
            enums.push(TrustBustOption::generated_enum_descriptor_data());
            enums.push(TriggerType::generated_enum_descriptor_data());
            enums.push(MatchType::generated_enum_descriptor_data());
            enums.push(TriggerRequirement::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
