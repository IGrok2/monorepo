datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["prismaSchemaFolder"]
}

/// A user in the db
model User {
  id           String @id @default(cuid())
  /// User's name. Intended to be a full name.
  name         String
  /// User's email address
  email        String @unique
  /// User's hashed password
  passwordHash String @map("password_hash")

  /// User's (depending on expiresAt) active reset code. If not set, no reset is available
  passwordResetCode       String?   @unique @map("password_reset_code")
  /// When the password reset request was made
  passwordResetCodeSentAt DateTime? @map("password_reset_code_sent_at")
  /// When the reset code was used (and the password was reset) last
  usedAt                  DateTime? @map("password_reset_used_at")

  /// Whether the email is verified
  emailVerified               Boolean   @default(false) @map("email_verified")
  /// The token to be used to validate the email
  emailToken                  String?   @unique @default(cuid()) @map("email_token")
  /// Last email sent to verify the email, this is how we determine if the code has expired
  emailVerificationMailSentAt DateTime  @default(now()) @map("email_verification_mail_sent_at")
  /// When the email was verified
  emailVerifiedAt             DateTime? @map("email_verified_at")

  //emailVerification       EmailVerification[]
  //passwordResetToken      PasswordResetToken[]

  /// The customer's optional Stripe customer ID - this is all we'll have if they're a paying customer
  stripeCustomerId String? @map("stripe_customer_id")

  containerRegistries       ContainerRegistry[]
  gitNamespaces             GitNamespace[]
  integrationVerificationId String? @map("integration_verification_id")
  integrationVerification   IntegrationVerification? @relation(fields: [integrationVerificationId], references: [id])

  /// The notifications that exist for this user
  notifications Notification[]
  /// The members that make this project whole
  Member        Member[]

  @@map("user")
}

// Perhaps use something like this to hande verification tokens in a cleaner way
//model EmailVerification {
//  id String @id @unique

//  expires DateTime // Expiration in ms
//  user    User     @relation(references: [id], fields: [user_id], onDelete: Cascade)
//  user_id String

//  @@index([user_id])
//  @@map("email_verification")
//}

//model PasswordResetToken {
//  id String @id @unique

//  expires DateTime // Expiration in ms
//  user    User     @relation(references: [id], fields: [user_id], onDelete: Cascade)
//  user_id String

//  @@index([user_id])
//  @@map("password_reset_token")
//}

/// A notification for a user or project
model Notification {
  id        String   @id @default(cuid())
  /// What the notification should display
  message   String
  /// Link to the notification source (if relevant)
  link      String?
  /// Whether the notification was read
  seen      Boolean  @default(false)
  /// When the notification was created
  createdAt DateTime @default(now()) @map("created_at")

  // Notifications belong to users
  user      User     @relation(references: [id], fields: [userId])
  userId    String @map("user_id")

  @@map("notification")
}

/// A Packetware Point of Presence
model Location {
  /// The name of this location, ex dallas
  id       String @id @db.VarChar(255)
  /// Exact location name, ex Dallas, Texas
  location String

  /// Servers in this location
  servers  Server[]
  volumes  Volume[]
  hostings Hosting[]

  @@map("location")
}

/// A Packetware server
model Server {
  id String @id @default(cuid())

  /// The hostname of the server - this should be cool!
  name       String    @db.VarChar(255)
  /// The public IP addresses of this server
  addresses  Address[]
  /// The points of
  location   Location  @relation(fields: [locationId], references: [id])
  locationId String @map("location_id")

  @@map("server")
}

/// Packetware public IP addresses
model Address {
  ip String @id @db.VarChar(255)

  /// The server object this IP address belongs to
  server   Server @relation(references: [id], fields: [serverId])
  /// The ID of the server this IP address belongs to
  serverId String @map("server_id")

  @@map("address")
}
