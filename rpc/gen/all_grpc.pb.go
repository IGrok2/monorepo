// we have to send all domain information to the server on startup! TODO!

// this should be absolutely everything!

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.4
// source: rpc/gen/all.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BigBaller_AllDomains_FullMethodName         = "/BigBaller/AllDomains"
	BigBaller_UpdateDomain_FullMethodName       = "/BigBaller/UpdateDomain"
	BigBaller_NewDomain_FullMethodName          = "/BigBaller/NewDomain"
	BigBaller_DeleteDomain_FullMethodName       = "/BigBaller/DeleteDomain"
	BigBaller_ClearCache_FullMethodName         = "/BigBaller/ClearCache"
	BigBaller_Challenge_FullMethodName          = "/BigBaller/Challenge"
	BigBaller_ChallengeRemoval_FullMethodName   = "/BigBaller/ChallengeRemoval"
	BigBaller_ChallengeCompleted_FullMethodName = "/BigBaller/ChallengeCompleted"
	BigBaller_RefreshChallenge_FullMethodName   = "/BigBaller/RefreshChallenge"
)

// BigBallerClient is the client API for BigBaller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BigBallerClient interface {
	// on startup message, includes all domains
	AllDomains(ctx context.Context, in *QueryResponse, opts ...grpc.CallOption) (*AllDomainSchema, error)
	// update domain after the user, or an admin, makes some changes
	UpdateDomain(ctx context.Context, in *PartialDomainSchema, opts ...grpc.CallOption) (*QueryResponse, error)
	// new domain on our service
	NewDomain(ctx context.Context, in *FullDomainSchema, opts ...grpc.CallOption) (*QueryResponse, error)
	// deleting a domain from our service
	DeleteDomain(ctx context.Context, in *DeleteDomainSchema, opts ...grpc.CallOption) (*QueryResponse, error)
	// clear cache
	ClearCache(ctx context.Context, in *ClearCacheMessage, opts ...grpc.CallOption) (*QueryResponse, error)
	// SSL
	Challenge(ctx context.Context, in *Token, opts ...grpc.CallOption) (*QueryResponse, error)
	// Challenge removal
	ChallengeRemoval(ctx context.Context, in *Token, opts ...grpc.CallOption) (*QueryResponse, error)
	// From proxy > main server
	ChallengeCompleted(ctx context.Context, in *Cert, opts ...grpc.CallOption) (*QueryResponse, error)
	// Challenge shuffler
	RefreshChallenge(ctx context.Context, in *SmartChallengeScript, opts ...grpc.CallOption) (*QueryResponse, error)
}

type bigBallerClient struct {
	cc grpc.ClientConnInterface
}

func NewBigBallerClient(cc grpc.ClientConnInterface) BigBallerClient {
	return &bigBallerClient{cc}
}

func (c *bigBallerClient) AllDomains(ctx context.Context, in *QueryResponse, opts ...grpc.CallOption) (*AllDomainSchema, error) {
	out := new(AllDomainSchema)
	err := c.cc.Invoke(ctx, BigBaller_AllDomains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) UpdateDomain(ctx context.Context, in *PartialDomainSchema, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_UpdateDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) NewDomain(ctx context.Context, in *FullDomainSchema, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_NewDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) DeleteDomain(ctx context.Context, in *DeleteDomainSchema, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_DeleteDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) ClearCache(ctx context.Context, in *ClearCacheMessage, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_ClearCache_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) Challenge(ctx context.Context, in *Token, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_Challenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) ChallengeRemoval(ctx context.Context, in *Token, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_ChallengeRemoval_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) ChallengeCompleted(ctx context.Context, in *Cert, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_ChallengeCompleted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigBallerClient) RefreshChallenge(ctx context.Context, in *SmartChallengeScript, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, BigBaller_RefreshChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BigBallerServer is the server API for BigBaller service.
// All implementations must embed UnimplementedBigBallerServer
// for forward compatibility
type BigBallerServer interface {
	// on startup message, includes all domains
	AllDomains(context.Context, *QueryResponse) (*AllDomainSchema, error)
	// update domain after the user, or an admin, makes some changes
	UpdateDomain(context.Context, *PartialDomainSchema) (*QueryResponse, error)
	// new domain on our service
	NewDomain(context.Context, *FullDomainSchema) (*QueryResponse, error)
	// deleting a domain from our service
	DeleteDomain(context.Context, *DeleteDomainSchema) (*QueryResponse, error)
	// clear cache
	ClearCache(context.Context, *ClearCacheMessage) (*QueryResponse, error)
	// SSL
	Challenge(context.Context, *Token) (*QueryResponse, error)
	// Challenge removal
	ChallengeRemoval(context.Context, *Token) (*QueryResponse, error)
	// From proxy > main server
	ChallengeCompleted(context.Context, *Cert) (*QueryResponse, error)
	// Challenge shuffler
	RefreshChallenge(context.Context, *SmartChallengeScript) (*QueryResponse, error)
	mustEmbedUnimplementedBigBallerServer()
}

// UnimplementedBigBallerServer must be embedded to have forward compatible implementations.
type UnimplementedBigBallerServer struct {
}

func (UnimplementedBigBallerServer) AllDomains(context.Context, *QueryResponse) (*AllDomainSchema, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllDomains not implemented")
}
func (UnimplementedBigBallerServer) UpdateDomain(context.Context, *PartialDomainSchema) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDomain not implemented")
}
func (UnimplementedBigBallerServer) NewDomain(context.Context, *FullDomainSchema) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewDomain not implemented")
}
func (UnimplementedBigBallerServer) DeleteDomain(context.Context, *DeleteDomainSchema) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDomain not implemented")
}
func (UnimplementedBigBallerServer) ClearCache(context.Context, *ClearCacheMessage) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearCache not implemented")
}
func (UnimplementedBigBallerServer) Challenge(context.Context, *Token) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Challenge not implemented")
}
func (UnimplementedBigBallerServer) ChallengeRemoval(context.Context, *Token) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeRemoval not implemented")
}
func (UnimplementedBigBallerServer) ChallengeCompleted(context.Context, *Cert) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeCompleted not implemented")
}
func (UnimplementedBigBallerServer) RefreshChallenge(context.Context, *SmartChallengeScript) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshChallenge not implemented")
}
func (UnimplementedBigBallerServer) mustEmbedUnimplementedBigBallerServer() {}

// UnsafeBigBallerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BigBallerServer will
// result in compilation errors.
type UnsafeBigBallerServer interface {
	mustEmbedUnimplementedBigBallerServer()
}

func RegisterBigBallerServer(s grpc.ServiceRegistrar, srv BigBallerServer) {
	s.RegisterService(&BigBaller_ServiceDesc, srv)
}

func _BigBaller_AllDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).AllDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_AllDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).AllDomains(ctx, req.(*QueryResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_UpdateDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartialDomainSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).UpdateDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_UpdateDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).UpdateDomain(ctx, req.(*PartialDomainSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_NewDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FullDomainSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).NewDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_NewDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).NewDomain(ctx, req.(*FullDomainSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_DeleteDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDomainSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).DeleteDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_DeleteDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).DeleteDomain(ctx, req.(*DeleteDomainSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_ClearCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearCacheMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).ClearCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_ClearCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).ClearCache(ctx, req.(*ClearCacheMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_Challenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).Challenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_Challenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).Challenge(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_ChallengeRemoval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).ChallengeRemoval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_ChallengeRemoval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).ChallengeRemoval(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_ChallengeCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).ChallengeCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_ChallengeCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).ChallengeCompleted(ctx, req.(*Cert))
	}
	return interceptor(ctx, in, info, handler)
}

func _BigBaller_RefreshChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartChallengeScript)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigBallerServer).RefreshChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BigBaller_RefreshChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigBallerServer).RefreshChallenge(ctx, req.(*SmartChallengeScript))
	}
	return interceptor(ctx, in, info, handler)
}

// BigBaller_ServiceDesc is the grpc.ServiceDesc for BigBaller service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BigBaller_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BigBaller",
	HandlerType: (*BigBallerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllDomains",
			Handler:    _BigBaller_AllDomains_Handler,
		},
		{
			MethodName: "UpdateDomain",
			Handler:    _BigBaller_UpdateDomain_Handler,
		},
		{
			MethodName: "NewDomain",
			Handler:    _BigBaller_NewDomain_Handler,
		},
		{
			MethodName: "DeleteDomain",
			Handler:    _BigBaller_DeleteDomain_Handler,
		},
		{
			MethodName: "ClearCache",
			Handler:    _BigBaller_ClearCache_Handler,
		},
		{
			MethodName: "Challenge",
			Handler:    _BigBaller_Challenge_Handler,
		},
		{
			MethodName: "ChallengeRemoval",
			Handler:    _BigBaller_ChallengeRemoval_Handler,
		},
		{
			MethodName: "ChallengeCompleted",
			Handler:    _BigBaller_ChallengeCompleted_Handler,
		},
		{
			MethodName: "RefreshChallenge",
			Handler:    _BigBaller_RefreshChallenge_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/gen/all.proto",
}
